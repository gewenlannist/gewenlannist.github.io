<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GW的尝试一-球体</title>
    <url>/2021/04/15/GW%E7%9A%84%E5%B0%9D%E8%AF%95%E4%B8%80-%E7%90%83%E4%BD%93/</url>
    <content><![CDATA[<p>  <img src="/2021/04/15/GW%E7%9A%84%E5%B0%9D%E8%AF%95%E4%B8%80-%E7%90%83%E4%BD%93/GW%E7%9A%84%E5%B0%9D%E8%AF%95%E4%B8%80-%E7%90%83%E4%BD%93.png"></p>
]]></content>
      <categories>
        <category>Paint</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>GW的尝试二-柠檬</title>
    <url>/2021/04/15/GW%E7%9A%84%E5%B0%9D%E8%AF%95%E4%BA%8C-%E6%9F%A0%E6%AA%AC/</url>
    <content><![CDATA[<p><img src="/2021/04/15/GW%E7%9A%84%E5%B0%9D%E8%AF%95%E4%BA%8C-%E6%9F%A0%E6%AA%AC/GW%E7%9A%84%E5%B0%9D%E8%AF%95%E4%BA%8C-%E6%9F%A0%E6%AA%AC.png"></p>
]]></content>
      <categories>
        <category>Paint</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>GW的第二张画-晚安</title>
    <url>/2021/04/09/GW%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%BC%A0%E7%94%BB-%E6%99%9A%E5%AE%89/</url>
    <content><![CDATA[<p><img src="/2021/04/09/GW%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%BC%A0%E7%94%BB-%E6%99%9A%E5%AE%89/GW%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%BC%A0%E7%94%BB-%E6%99%9A%E5%AE%89.png"></p>
]]></content>
      <categories>
        <category>Paint</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>GW的第一张画-皮卡丘</title>
    <url>/2021/04/06/GW%E7%9A%84%E7%AC%AC%E4%B8%80%E5%BC%A0%E7%94%BB-%E7%9A%AE%E5%8D%A1%E4%B8%98/</url>
    <content><![CDATA[<p><img src="/2021/04/06/GW%E7%9A%84%E7%AC%AC%E4%B8%80%E5%BC%A0%E7%94%BB-%E7%9A%AE%E5%8D%A1%E4%B8%98/firstpikaqiu.png"></p>
]]></content>
      <categories>
        <category>Paint</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>GW的第三张画-女孩tozw</title>
    <url>/2021/04/13/GW%E7%9A%84%E7%AC%AC%E4%B8%89%E5%BC%A0%E7%94%BB-%E5%A5%B3%E5%AD%A9tozw/</url>
    <content><![CDATA[<p><img src="/2021/04/13/GW%E7%9A%84%E7%AC%AC%E4%B8%89%E5%BC%A0%E7%94%BB-%E5%A5%B3%E5%AD%A9tozw/GW%E7%9A%84%E7%AC%AC%E4%B8%89%E5%BC%A0%E7%94%BB-%E5%A5%B3%E5%AD%A9tozw.png"></p>
]]></content>
      <categories>
        <category>Paint</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>GW的第四张画-男孩tohb</title>
    <url>/2021/04/29/GW%E7%9A%84%E7%AC%AC%E5%9B%9B%E5%BC%A0%E7%94%BB-%E7%94%B7%E5%AD%A9tohb/</url>
    <content><![CDATA[<p><img src="/2021/04/29/GW%E7%9A%84%E7%AC%AC%E5%9B%9B%E5%BC%A0%E7%94%BB-%E7%94%B7%E5%AD%A9tohb/GW%E7%9A%84%E7%AC%AC%E5%9B%9B%E5%BC%A0%E7%94%BB-%E7%94%B7%E5%AD%A9tohb.png"></p>
]]></content>
      <categories>
        <category>Paint</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql1-mysql介绍</title>
    <url>/2021/05/16/MySql1/</url>
    <content><![CDATA[<p><img src="/2021/05/16/MySql1/1.png"></p>
<a id="more"></a>

<h1 id="与MySQL的第一次亲密接触"><a href="#与MySQL的第一次亲密接触" class="headerlink" title="与MySQL的第一次亲密接触"></a>与MySQL的第一次亲密接触</h1><h2 id="为什么学习数据库？"><a href="#为什么学习数据库？" class="headerlink" title="为什么学习数据库？"></a>为什么学习数据库？</h2><ul>
<li>实现数据持久化</li>
<li>使用完整的管理系统统一管理，易于查询</li>
</ul>
<h2 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h2><ul>
<li><p>DB：数据库（database）：存储数据的“仓库”。它保存了一系列有组织的数据。</p>
</li>
<li><p>DBMS：</p>
<ul>
<li>数据库管理系统（Database Management System）。数据库是通过DBMS创建和操作的容器</li>
<li>常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer等。</li>
</ul>
</li>
<li><p>SQL</p>
<ul>
<li>结构化查询语言（Structure Query Language）：专门用来与数据库通信的语言。</li>
<li>SQL的优点：①简单易学；②不是某个特定数据库供应商专有的语言，几乎所有DBMS都支持SQL；③虽然简单，但实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/16/MySql1/2.png"></p>
<h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><ul>
<li>将数据放到表中，表再放到库中</li>
<li>一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</li>
<li>表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”。</li>
<li>表中的数据是按行存储的，每一行类似于java中的“对象”。</li>
</ul>
<h2 id="MySQL软件"><a href="#MySQL软件" class="headerlink" title="MySQL软件"></a>MySQL软件</h2><ul>
<li>MySQL数据库隶属于MySQLAB公司，总部位于瑞典，后被oracle收购。<br>优点：①成本低：开放源代码，一般可以免费试用；②简单：很容易安装和使用；③性能高：执行很快。</li>
<li>DBMS分为两类：①基于共享文件系统的DBMS （Access）；②基于客户机——服务器的DBMS（MySQL、Oracle、SqlServer）。<br>版本可分为：社区版（免费），企业版（收费）。</li>
<li>Windows平台下下载：<a href="http://dev.mysql.com/downloads/mysql">http://dev.mysql.com/downloads/mysql</a><br>完整安装卸载步骤：<a href="https://blog.csdn.net/Y_BlueBlack/article/details/81433401">https://blog.csdn.net/Y_BlueBlack/article/details/81433401</a></li>
</ul>
<h4 id="启动和停止MySQL服务"><a href="#启动和停止MySQL服务" class="headerlink" title="启动和停止MySQL服务"></a>启动和停止MySQL服务</h4><ul>
<li>方式一：右击此电脑—管理—服务—启动或停止MySQL服务</li>
<li>方式二：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以管理员身份打开命令提示符</span><br><span class="line">启动：net start mysql服务名 （如直接mysqlgewen）</span><br><span class="line">停止：net stop mysql服务名</span><br></pre></td></tr></table></figure>


<h4 id="MySQL服务端的登录和退出"><a href="#MySQL服务端的登录和退出" class="headerlink" title="MySQL服务端的登录和退出"></a>MySQL服务端的登录和退出</h4><ul>
<li><p>登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql–h 主机名–u用户名–p密码</span><br><span class="line">例：mysql -h localhost -u root -proot</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit或ctrl+C</span><br></pre></td></tr></table></figure>





<h2 id="MySQL常见命令介绍"><a href="#MySQL常见命令介绍" class="headerlink" title="MySQL常见命令介绍"></a>MySQL常见命令介绍</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入mysql, 在命令行中输入</span><br><span class="line">mysql–uroot–p####  (其中：####表示密码）</span><br><span class="line">例：mysql -uroot -proot</span><br><span class="line"></span><br><span class="line">查看mysql中有哪些个数据库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">新建一个数据库</span><br><span class="line">create database 数据库名;</span><br><span class="line">例：create database book;</span><br><span class="line"></span><br><span class="line">选择一个数据库</span><br><span class="line">use 数据库名称;</span><br><span class="line">例：use test;</span><br><span class="line"></span><br><span class="line">查询数据表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">查看指定的数据库中有哪些数据表</span><br><span class="line">show tables from 数据库名;</span><br><span class="line">例：show tables from mysql;</span><br><span class="line"></span><br><span class="line">查询当前所在数据库</span><br><span class="line">select database();</span><br><span class="line"></span><br><span class="line">新建一个数据表</span><br><span class="line">create table math(</span><br><span class="line">id int,</span><br><span class="line">name varchar(20));</span><br><span class="line"></span><br><span class="line">查看表的结构</span><br><span class="line">desc 表名;</span><br><span class="line">例：desc math;</span><br><span class="line"></span><br><span class="line">查看表中的所有记录</span><br><span class="line">select * from 表名;</span><br><span class="line">例： select * from math;</span><br><span class="line"></span><br><span class="line">向表中插入记录</span><br><span class="line">insert into 表名(列名列表) values(列对应的值的列表);</span><br><span class="line">注意：插入varchar或date 型的数据要用单引号引起来</span><br><span class="line">例：insert into math (id,name) values(1,&quot;ton&quot;);</span><br><span class="line"></span><br><span class="line">修改记录</span><br><span class="line">update 表名 set 列1 &#x3D; 列1的值, 列2 &#x3D; 列2的值where ..</span><br><span class="line">例：update math set name&#x3D;&quot;wugang&quot; where id&#x3D;1;</span><br><span class="line"></span><br><span class="line">删除记录</span><br><span class="line">delete from 表名 where ...</span><br><span class="line">例：delete from math where id&#x3D;1;</span><br><span class="line"></span><br><span class="line">删除数据表</span><br><span class="line">drop table 表名;</span><br><span class="line">例：drop table math;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看MySQL服务端版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line"></span><br><span class="line">没有登录到mysql服务端</span><br><span class="line">在cmd命令界面输入：mysql --version</span><br></pre></td></tr></table></figure>

<ul>
<li><p>MySQL的语法规范</p>
<ul>
<li><p>不区分大小写,但建议关键字大写，表名、列名小写</p>
</li>
<li><p>每句话用;或\g结尾，最好用分号结尾</p>
</li>
<li><p>每条命令根据需要，可以进行缩进或换行</p>
</li>
<li><p>注释：①单行注释：#注释文字；②单行注释：– 注释文字；③多行注释：/* 注释文字 */</p>
</li>
</ul>
</li>
<li><p>图形化用户界面客户端介绍：</p>
<ul>
<li>主要分为两种——SQLyog 12、Navicat 12 for mysql</li>
</ul>
</li>
</ul>
<h2 id="SQL语言的分类"><a href="#SQL语言的分类" class="headerlink" title="SQL语言的分类"></a>SQL语言的分类</h2><ul>
<li>DQL（Data Query Language）：数据查询语言，用于检索数据库中的数据，主要是SELECT语句；</li>
<li>DML（Data Manipulation Language)：数据操纵语言，用于改变数据库中的数据，主要包括INSERT、UPDATE和DELETE语句；</li>
<li>DDL（Data Definition Language)：数据定义语言，用于库和表的创建、修改、删除。主要包括CREATE、DROP、ALTER语句；</li>
<li>DCL（Data Control Language)：数据控制语言，用于定义用户的访问权限和安全级别。主要包括GRANT和REVOKE语句；</li>
<li>TCL（Transaction Control Language)：事务控制语言，用于维护数据的一致性，包括COMMIT、ROLLBACK和SAVEPOINT语句。</li>
</ul>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>GW的第五张画-眼镜微笑男孩</title>
    <url>/2021/05/06/GW%E7%9A%84%E7%AC%AC%E4%BA%94%E5%BC%A0%E7%94%BB-%E7%9C%BC%E9%95%9C%E5%BE%AE%E7%AC%91%E7%94%B7%E5%AD%A9/</url>
    <content><![CDATA[<p><img src="/2021/05/06/GW%E7%9A%84%E7%AC%AC%E4%BA%94%E5%BC%A0%E7%94%BB-%E7%9C%BC%E9%95%9C%E5%BE%AE%E7%AC%91%E7%94%B7%E5%AD%A9/GW%E7%9A%84%E7%AC%AC%E4%BA%94%E5%BC%A0%E7%94%BB-%E7%9C%BC%E9%95%9C%E5%BE%AE%E7%AC%91%E7%94%B7%E5%AD%A9.png"></p>
]]></content>
      <categories>
        <category>Paint</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql4-DQL数据查询语言后五项</title>
    <url>/2021/05/16/MySql4/</url>
    <content><![CDATA[<p><img src="/2021/05/16/MySql4/1.png"></p>
<a id="more"></a>

<h1 id="DQL语言"><a href="#DQL语言" class="headerlink" title="DQL语言"></a>DQL语言</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><ul>
<li><p>含义:又称多表查询,当查询的数据来自多个表时,就会用到连接查询</p>
</li>
<li><p>笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行</p>
</li>
<li><p>发生原因：没有有效的连接条件</p>
</li>
<li><p>如何避免：添加有效的连接条件</p>
</li>
<li><p>分类</p>
<ul>
<li>按年代分类：<pre><code>sql92标准:仅仅支持内连接
  sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>按功能分类：<br>内连接：</p>
<pre><code>等值连接
非等值连接
自连接</code></pre>
<p>外连接：</p>
<pre><code>左外连接
右外连接
全外连接        </code></pre>
<p>交叉连接</p>
</li>
</ul>
<p>1.多表等值连接的结果为多表的交集部分 2.n表连接，至少需要n-1个连接条件 3.多表的顺序没有要求 4.一般需要为表起别名 5.可以搭配前面介绍的所有子句使用，比如排序、分组、筛选*</p>
<p><em>#2、为表起别名</em> <em>/\</em> 1.提高语句的简洁度 2.区分多个重名的字段 注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定*</p>
<p>select 查询列表<br>from 表1 别名 【连接类型】<br>join 表2 别名<br>on 连接条件<br>【where 筛选条件】<br>【group by 分组】<br>【having 筛选条件】<br>【order by 排序列表】</p>
<h4 id="sql99标准案例"><a href="#sql99标准案例" class="headerlink" title="sql99标准案例"></a>sql99标准案例</h4><ul>
<li><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名 【连接类型】</span><br><span class="line">join 表2 别名 </span><br><span class="line">on 连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组】</span><br><span class="line">【having 筛选条件】</span><br><span class="line">【order by 排序列表】</span><br></pre></td></tr></table></figure>
</li>
<li><p>分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内连接（★）：inner(交集)</span><br><span class="line">外连接</span><br><span class="line">	左外(★):left 【outer】(主表全部包括对应从表为null)</span><br><span class="line">	右外(★)：right 【outer】</span><br><span class="line">	全外：full【outer】</span><br><span class="line">交叉连接：cross </span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、内连接</span><br><span class="line">&#x2F;*</span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">inner join 表2 别名</span><br><span class="line">on 连接条件;</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">等值</span><br><span class="line">非等值</span><br><span class="line">自连接</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">①添加排序、分组、筛选</span><br><span class="line">②inner可以省略</span><br><span class="line">③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读</span><br><span class="line">④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#1、等值连接</span><br><span class="line">#案例1.查询员工名、部门名</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name FROM departments d</span><br><span class="line">INNER JOIN  employees e</span><br><span class="line">ON e.&#96;department_id&#96; &#x3D; d.&#96;department_id&#96;;</span><br><span class="line"></span><br><span class="line">#案例2.查询名字中包含e的员工名和工种名（添加筛选）</span><br><span class="line">SELECT last_name,job_title FROM employees e</span><br><span class="line">INNER JOIN jobs j ON e.&#96;job_id&#96;&#x3D;  j.&#96;job_id&#96;</span><br><span class="line">WHERE e.&#96;last_name&#96; LIKE &#39;%e%&#39;;</span><br><span class="line"></span><br><span class="line">#案例3.查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）</span><br><span class="line"></span><br><span class="line">#1.查询每个城市的部门个数</span><br><span class="line">#2.在1结果上筛选满足条件的</span><br><span class="line">SELECT city,COUNT(*) 部门个数</span><br><span class="line">FROM departments d</span><br><span class="line">INNER JOIN locations l</span><br><span class="line">ON d.&#96;location_id&#96;&#x3D;l.&#96;location_id&#96;</span><br><span class="line">GROUP BY city</span><br><span class="line">HAVING COUNT(*)&gt;3;</span><br><span class="line"></span><br><span class="line">#案例4.查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）</span><br><span class="line"></span><br><span class="line">#1.查询每个部门的员工个数</span><br><span class="line">SELECT COUNT(*),department_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.&#96;department_id&#96;&#x3D;d.&#96;department_id&#96;</span><br><span class="line">GROUP BY department_name;</span><br><span class="line"></span><br><span class="line">#2.在1结果上筛选员工个数&gt;3的记录，并排序</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) 个数,department_name</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d</span><br><span class="line">ON e.&#96;department_id&#96;&#x3D;d.&#96;department_id&#96;</span><br><span class="line">GROUP BY department_name</span><br><span class="line">HAVING COUNT(*)&gt;3</span><br><span class="line">ORDER BY COUNT(*) DESC;</span><br><span class="line"></span><br><span class="line">#案例5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name,job_title</span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN departments d ON e.&#96;department_id&#96;&#x3D;d.&#96;department_id&#96;</span><br><span class="line">INNER JOIN jobs j ON e.&#96;job_id&#96; &#x3D; j.&#96;job_id&#96;</span><br><span class="line">ORDER BY department_name DESC;</span><br><span class="line"></span><br><span class="line">#二、非等值连接</span><br><span class="line"></span><br><span class="line">#查询员工的工资级别</span><br><span class="line"></span><br><span class="line">SELECT salary,grade_level</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN job_grades g</span><br><span class="line">ON e.&#96;salary&#96; BETWEEN g.&#96;lowest_sal&#96; AND g.&#96;highest_sal&#96;;</span><br><span class="line"> </span><br><span class="line">#查询工资级别的个数&gt;20的个数，并且按工资级别降序</span><br><span class="line">SELECT COUNT(*),grade_level</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN job_grades g</span><br><span class="line">ON e.&#96;salary&#96; BETWEEN g.&#96;lowest_sal&#96; AND g.&#96;highest_sal&#96;</span><br><span class="line">GROUP BY grade_level</span><br><span class="line">HAVING COUNT(*)&gt;20</span><br><span class="line">ORDER BY grade_level DESC;</span><br><span class="line"></span><br><span class="line">#三、自连接</span><br><span class="line"> </span><br><span class="line">#查询员工的名字、上级的名字</span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">ON e.&#96;manager_id&#96;&#x3D; m.&#96;employee_id&#96;;</span><br><span class="line"> </span><br><span class="line">#查询姓名中包含字符k的员工的名字、上级的名字</span><br><span class="line">SELECT e.last_name,m.last_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">ON e.&#96;manager_id&#96;&#x3D; m.&#96;employee_id&#96;</span><br><span class="line">WHERE e.&#96;last_name&#96; LIKE &#39;%k%&#39;;</span><br><span class="line"></span><br><span class="line">#二、外连接</span><br><span class="line"> </span><br><span class="line">&#x2F;*</span><br><span class="line">应用场景：用于查询一个表中有，另一个表没有的记录</span><br><span class="line"> </span><br><span class="line">特点：</span><br><span class="line">1、外连接的查询结果为主表中的所有记录</span><br><span class="line">	如果从表中有和它匹配的，则显示匹配的值</span><br><span class="line">	如果从表中没有和它匹配的，则显示null</span><br><span class="line">	外连接查询结果&#x3D;内连接结果+主表中有而从表没有的记录</span><br><span class="line">2、左外连接，left join左边的是主表</span><br><span class="line">   右外连接，right join右边的是主表</span><br><span class="line">3、左外和右外交换两个表的顺序，可以实现同样的效果 </span><br><span class="line">4、全外连接&#x3D;内连接的结果+表1中有但表2没有的+表2中有但表1没有的</span><br><span class="line">*&#x2F;</span><br><span class="line">#引入：查询男朋友 不在男神表的的女神名</span><br><span class="line"></span><br><span class="line">SELECT * FROM beauty;</span><br><span class="line">SELECT * FROM boys;</span><br><span class="line"> </span><br><span class="line">#左外连接</span><br><span class="line">SELECT b.*,bo.* FROM boys bo</span><br><span class="line">LEFT OUTER JOIN beauty b</span><br><span class="line">ON b.&#96;boyfriend_id&#96; &#x3D; bo.&#96;id&#96;</span><br><span class="line">WHERE b.&#96;id&#96; IS NULL;</span><br><span class="line"> </span><br><span class="line">#案例1：查询哪个部门没有员工</span><br><span class="line">#左外</span><br><span class="line">SELECT d.*,e.employee_id</span><br><span class="line">FROM departments d</span><br><span class="line">LEFT OUTER JOIN employees e</span><br><span class="line">ON d.&#96;department_id&#96; &#x3D; e.&#96;department_id&#96;</span><br><span class="line">WHERE e.&#96;employee_id&#96; IS NULL;</span><br><span class="line"></span><br><span class="line">#右外</span><br><span class="line"> </span><br><span class="line">SELECT d.*,e.employee_id</span><br><span class="line">FROM employees e</span><br><span class="line">RIGHT OUTER JOIN departments d</span><br><span class="line">ON d.&#96;department_id&#96; &#x3D; e.&#96;department_id&#96;</span><br><span class="line">WHERE e.&#96;employee_id&#96; IS NULL;</span><br><span class="line"></span><br><span class="line">#全外</span><br><span class="line"></span><br><span class="line">USE girls;</span><br><span class="line">SELECT b.*,bo.* FROM beauty b</span><br><span class="line">FULL OUTER JOIN boys bo</span><br><span class="line">ON b.&#96;boyfriend_id&#96; &#x3D; bo.id;</span><br><span class="line"></span><br><span class="line">#交叉连接</span><br><span class="line">(笛卡尔乘积)</span><br><span class="line">SELECT b.*,bo.* FROM beauty b</span><br><span class="line">CROSS JOIN boys bo;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul>
<li>含义:出现在其他语句中的select语句,称为子查询或内查询外部的查询语句，称为主查询或外查询。</li>
<li>分类</li>
</ul>
<p><img src="/2021/05/16/MySql4/2.png"></p>
<ul>
<li><p>案例</p>
<ul>
<li><p>特点：<br>①子查询放在小括号内<br>②子查询一般放在条件的右侧<br>③标量子查询，一般搭配着单行操作符使用</p>
<p>​    &gt; &lt; &gt;= &lt;= = &lt;&gt;</p>
<p>​    列子查询，一般搭配着多行操作符使用<br>​    in、any/some、all</p>
<p>④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、where或having后面</span><br><span class="line">&#x2F;*</span><br><span class="line">1、标量子查询（单行子查询）</span><br><span class="line">2、列子查询（多行子查询）</span><br><span class="line">3、行子查询（多列多行）</span><br><span class="line">*&#x2F;</span><br><span class="line">#1.标量子查询（单行子查询）★</span><br><span class="line"></span><br><span class="line">#案例1：谁的工资比 Abel 高?</span><br><span class="line"></span><br><span class="line">#①查询Abel的工资</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name &#x3D; &#39;Abel&#39;;</span><br><span class="line"></span><br><span class="line">#②查询员工的信息，满足 salary&gt;①结果</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&gt;(</span><br><span class="line"></span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name &#x3D; &#39;Abel&#39;</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</span><br><span class="line"></span><br><span class="line">#①查询141号员工的job_id</span><br><span class="line">SELECT job_id FROM employees</span><br><span class="line">WHERE employee_id &#x3D; 141;</span><br><span class="line"></span><br><span class="line">#②查询143号员工的salary</span><br><span class="line">SELECT salary FROM employees</span><br><span class="line">WHERE employee_id &#x3D; 143;</span><br><span class="line"></span><br><span class="line">#③查询员工的姓名，job_id 和工资，要求job_id&#x3D;①并且salary&gt;②</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE job_id &#x3D; (</span><br><span class="line">	SELECT job_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE employee_id &#x3D; 141</span><br><span class="line">) AND salary&gt;(</span><br><span class="line">	SELECT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE employee_id &#x3D; 143</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例3：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class="line"></span><br><span class="line">#①查询公司的最低工资</span><br><span class="line">SELECT MIN(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">#②查询last_name,job_id和salary，要求salary&#x3D;①</span><br><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&#x3D;(</span><br><span class="line">	SELECT MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资</span><br><span class="line"></span><br><span class="line">#①查询50号部门的最低工资</span><br><span class="line">SELECT  MIN(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id &#x3D; 50;</span><br><span class="line"></span><br><span class="line">#②查询每个部门的最低工资</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">#③ 在②基础上筛选，满足min(salary)&gt;①</span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MIN(salary)&gt;(</span><br><span class="line">	SELECT  MIN(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE department_id &#x3D; 50</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#非法使用标量子查询</span><br><span class="line"></span><br><span class="line">SELECT MIN(salary),department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING MIN(salary)&gt;(</span><br><span class="line">	SELECT  salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE department_id &#x3D; 250</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#2.列子查询（多行子查询）★</span><br><span class="line">#案例1：返回location_id是1400或1700的部门中的所有员工姓名</span><br><span class="line"></span><br><span class="line">#①查询location_id是1400或1700的部门编号</span><br><span class="line">SELECT DISTINCT department_id</span><br><span class="line">FROM departments</span><br><span class="line">WHERE location_id IN(1400,1700);</span><br><span class="line"></span><br><span class="line">#②查询员工姓名，要求部门号是①列表中的某一个</span><br><span class="line"></span><br><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id  &lt;&gt;ALL(</span><br><span class="line">	SELECT DISTINCT department_id</span><br><span class="line">	FROM departments</span><br><span class="line">	WHERE location_id IN(1400,1700)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</span><br><span class="line"></span><br><span class="line">#①查询job_id为‘IT_PROG’部门任一工资</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT salary FROM employees</span><br><span class="line">WHERE job_id &#x3D; &#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line">#②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;ANY(</span><br><span class="line">	SELECT DISTINCT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary</span><br><span class="line"></span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;ALL(</span><br><span class="line">	SELECT DISTINCT salary</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line"></span><br><span class="line">SELECT last_name,employee_id,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary&lt;(</span><br><span class="line">	SELECT MIN( salary)</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE job_id &#x3D; &#39;IT_PROG&#39;</span><br><span class="line"></span><br><span class="line">) AND job_id&lt;&gt;&#39;IT_PROG&#39;;</span><br><span class="line"></span><br><span class="line">#3、行子查询（结果集一行多列或多行多列）</span><br><span class="line"></span><br><span class="line">#案例：查询员工编号最小并且工资最高的员工信息</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE (employee_id,salary)&#x3D;(</span><br><span class="line">	SELECT MIN(employee_id),MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#①查询最小的员工编号</span><br><span class="line">SELECT MIN(employee_id) FROM employees;</span><br><span class="line"></span><br><span class="line">#②查询最高工资</span><br><span class="line">SELECT MAX(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">#③查询员工信息</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE employee_id&#x3D;(</span><br><span class="line">	SELECT MIN(employee_id)</span><br><span class="line">	FROM employees</span><br><span class="line">)AND salary&#x3D;(</span><br><span class="line">	SELECT MAX(salary)</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#二、select后面</span><br><span class="line">&#x2F;*</span><br><span class="line">仅仅支持标量子查询</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#案例：查询每个部门的员工个数</span><br><span class="line"></span><br><span class="line">SELECT d.*,(</span><br><span class="line">	SELECT COUNT(*)</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE e.department_id &#x3D; d.&#96;department_id&#96;</span><br><span class="line"> ) 个数</span><br><span class="line"> FROM departments d;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#案例2：查询员工号&#x3D;102的部门名</span><br><span class="line"> </span><br><span class="line">SELECT (</span><br><span class="line">	SELECT department_name,e.department_id</span><br><span class="line">	FROM departments d</span><br><span class="line">	INNER JOIN employees e</span><br><span class="line">	ON d.department_id&#x3D;e.department_id</span><br><span class="line">	WHERE e.employee_id&#x3D;102</span><br><span class="line">	</span><br><span class="line">) 部门名;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#三、from后面</span><br><span class="line">&#x2F;*</span><br><span class="line">将子查询结果充当一张表，要求必须起别名</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#案例：查询每个部门的平均工资的工资等级</span><br><span class="line">#①查询每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id</span><br><span class="line">FROM employees GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">SELECT * FROM job_grades;</span><br><span class="line"></span><br><span class="line">#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</span><br><span class="line"></span><br><span class="line">SELECT  ag_dep.*,g.&#96;grade_level&#96;</span><br><span class="line">FROM (</span><br><span class="line">	SELECT AVG(salary) ag,department_id</span><br><span class="line">	FROM employees</span><br><span class="line">	GROUP BY department_id</span><br><span class="line">) ag_dep</span><br><span class="line">INNER JOIN job_grades g</span><br><span class="line">ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#四、exists后面（相关子查询）</span><br><span class="line">&#x2F;*</span><br><span class="line">语法：</span><br><span class="line">exists(完整的查询语句)</span><br><span class="line">结果：</span><br><span class="line">1或0</span><br><span class="line">*&#x2F;</span><br><span class="line">SELECT EXISTS(SELECT employee_id FROM employees WHERE salary&#x3D;300000);</span><br><span class="line"></span><br><span class="line">#案例1：查询有员工的部门名</span><br><span class="line"></span><br><span class="line">#in</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE d.&#96;department_id&#96; IN(</span><br><span class="line">	SELECT department_id</span><br><span class="line">	FROM employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#exists</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE EXISTS(</span><br><span class="line">	SELECT *</span><br><span class="line">	FROM employees e</span><br><span class="line">	WHERE d.&#96;department_id&#96;&#x3D;e.&#96;department_id&#96;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#案例2：查询没有女朋友的男神信息</span><br><span class="line"></span><br><span class="line">#in</span><br><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE bo.id NOT IN(</span><br><span class="line">	SELECT boyfriend_id</span><br><span class="line">	FROM beauty</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#exists</span><br><span class="line">SELECT bo.*</span><br><span class="line">FROM boys bo</span><br><span class="line">WHERE NOT EXISTS(</span><br><span class="line">	SELECT boyfriend_id</span><br><span class="line">	FROM beauty b</span><br><span class="line">	WHERE bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><ul>
<li><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求。</p>
</li>
<li><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	select 查询列表</span><br><span class="line">	from 表</span><br><span class="line">	[join type join 表2</span><br><span class="line">	on 连接条件</span><br><span class="line">	where 筛选条件</span><br><span class="line">	group by 分组字段</span><br><span class="line">	having 分组后的筛选</span><br><span class="line">	order by 排序的字段]</span><br><span class="line">	limit [offset,]size;</span><br><span class="line">注意</span><br><span class="line">	offset要显示条目的起始索引（起始索引从0开始）</span><br><span class="line">	size 要显示的条目个数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>特点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①limit语句放在查询语句的最后</span><br><span class="line">②公式</span><br><span class="line">	要显示的页数 page，每页的条目数size</span><br><span class="line">	</span><br><span class="line">select 查询列表 from 表</span><br><span class="line">limit (page-1)*size,size;</span><br><span class="line">	</span><br><span class="line">size&#x3D;10</span><br><span class="line">page  </span><br><span class="line">1	0			(1-1)*10</span><br><span class="line">2  	10			(2-1)*10</span><br><span class="line">3	20			(3-1)*10</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1：查询前五条员工信息</span><br><span class="line">SELECT * FROM  employees LIMIT 0,5;</span><br><span class="line">SELECT * FROM  employees LIMIT 5;</span><br><span class="line"></span><br><span class="line">#案例2：查询第11条——第25条</span><br><span class="line">SELECT * FROM employees LIMIT 10,15;</span><br><span class="line"></span><br><span class="line">#案例3：有奖金的员工信息，并且工资较高的前10名显示出来</span><br><span class="line">SELECT * FROM employees </span><br><span class="line">WHERE commission_pct IS NOT NULL </span><br><span class="line">ORDER BY salary DESC LIMIT 10 ;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><ul>
<li><p>含义：union (联合、合并)：将多条查询语句的结果合并成一个结果。</p>
</li>
<li><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询语句1</span><br><span class="line">union 【all】</span><br><span class="line">查询语句2</span><br><span class="line">union 【all】</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>意义</p>
<ul>
<li>将一条比较复杂的查询语句拆分成多条语句</li>
<li>适用于查询多个表的时候，查询的列基本是一致。</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>要求多条查询语句的查询列数是一致的！</li>
<li>要求多条查询语句的查询的每一列的类型和顺序最好一致</li>
<li>union关键字默认去重，如果使用union all 可以包含重复项</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#引入的案例：查询部门编号&gt;90或邮箱包含a的员工信息</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees WHERE email LIKE &#39;%a%&#39; OR department_id&gt;90;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees  WHERE email LIKE &#39;%a%&#39;</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM employees  WHERE department_id&gt;90;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息 一个结果</span><br><span class="line"></span><br><span class="line">SELECT id,cname,csex FROM t_ca WHERE csex&#x3D;&#39;男&#39;</span><br><span class="line">UNION</span><br><span class="line">SELECT t_id,tName,tGender FROM t_ua WHERE tGender&#x3D;&#39;male&#39;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql3-常见函数</title>
    <url>/2021/05/16/MySql3/</url>
    <content><![CDATA[<p>字符函数、数学函数、日期函数、其他函数、流程控制函数</p>
<p>单行函数：字符函数、数学函数、日期函数、其他函数、流程控制函数</p>
<p>分组函数</p>
<a id="more"></a>

<h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><ul>
<li><p>概念：类似于Java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</p>
</li>
<li><p>优点：1.隐藏了实现细节 2.提高了代码的重用性</p>
</li>
<li><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 函数名(实参列表) 【from 表】;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：</p>
<p>1.叫什么(函数名)</p>
<p>2.干什么(函数功能)</p>
</li>
<li><p>分类:</p>
<p>1.单行函数，如concat、length、ifnull等<br>2.分组函数，做统计使用</p>
</li>
</ul>
<h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><ul>
<li><p>单行函数分类：字符函数、数学函数、日期函数、其他函数、流程控制函数</p>
</li>
<li><p>字符函数具体案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一.字符函数</span><br><span class="line">#1.length 获取参数值的字节值</span><br><span class="line">SELECT LENGTH(&#39;subei&#39;);</span><br><span class="line">SELECT LENGTH(&#39;鬼谷子qwe&#39;);</span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &#39;%char%&#39;;</span><br><span class="line"></span><br><span class="line">#2.concat 拼接字符串</span><br><span class="line">SELECT CONCAT(last_name,&#39;_&#39;,first_name) 姓名 FROM employees;</span><br><span class="line"></span><br><span class="line">#3.upper:变大写、lower：变小写</span><br><span class="line"></span><br><span class="line">SELECT UPPER(&#39;ton&#39;);</span><br><span class="line">SELECT LOWER(&#39;ton&#39;);</span><br><span class="line"></span><br><span class="line">#示例：将姓变大写，名变小写，然后拼接</span><br><span class="line">SELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名 FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4.substr、substring</span><br><span class="line">#注意:索引从1开始</span><br><span class="line"></span><br><span class="line">#截取从指定所有处后面的所以字符</span><br><span class="line">SELECT SUBSTR(&#39;吴刚伐桂在天上&#39;,4) out_put;</span><br><span class="line"></span><br><span class="line">#截取从指定索引处指定字符长度的字符</span><br><span class="line">SELECT SUBSTR(&#39;吴刚伐桂在天上&#39;,1,2) out_put;</span><br><span class="line"></span><br><span class="line">#案例:姓名中首字符大写,其他字符小写，然后用_拼接,显示出来</span><br><span class="line">SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&#39;_&#39;,LOWER(SUBSTR(last_name,2))) out_put FROM employees;</span><br><span class="line"></span><br><span class="line">#5.instr:获取子串第一次出现的索引,找不到返回0</span><br><span class="line">SELECT INSTR(&#39;MySQL技术进阶&#39;,&#39;技术&#39;) AS out_put;</span><br><span class="line"></span><br><span class="line">#6.trim:去前后空格</span><br><span class="line"></span><br><span class="line">SELECT LENGTH(TRIM(&#39;	霍山	&#39;)) AS out_put;</span><br><span class="line"></span><br><span class="line">SELECT TRIM(&#39;+&#39; FROM &#39;++++李刚+++刘邦+++&#39;) AS out_put;</span><br><span class="line"></span><br><span class="line">#7.lpad:用指定的字符实现左填充指定长度</span><br><span class="line">SELECT LPAD(&#39;梅林&#39;,8,&#39;+&#39;) AS out_put;</span><br><span class="line"></span><br><span class="line">#8.rpad:用指定的字符实现右填充指定长度</span><br><span class="line">SELECT RPAD(&#39;梅林&#39;,5,&#39;&amp;&#39;) AS out_put;</span><br><span class="line"></span><br><span class="line">#9.replace:替换</span><br><span class="line">SELECT REPLACE(&#39;莉莉伊万斯的青梅竹马是詹姆&#39;,&#39;詹姆&#39;,&#39;斯内普&#39;) AS out_put;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>数学函数具体案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.round:四舍五入</span><br><span class="line">SELECT ROUND(1.45);</span><br><span class="line">SELECT ROUND(1.567,2);</span><br><span class="line"></span><br><span class="line">#2.ceil:向上取整,返回&gt;&#x3D;该参数的最小整数</span><br><span class="line">SELECT CEIL(1.005);</span><br><span class="line">SELECT CEIL(-1.002);</span><br><span class="line"></span><br><span class="line">#3.floor:向下取整,返回&lt;&#x3D;该参数的最大整数</span><br><span class="line">SELECT FLOOR(-9.99);</span><br><span class="line"></span><br><span class="line">#4.truncate:截断</span><br><span class="line">SELECT TRUNCATE(1.65,1);</span><br><span class="line"></span><br><span class="line">#5.mod:取余</span><br><span class="line">SELECT MOD(10,3);</span><br><span class="line"></span><br><span class="line">#6.rand:获取随机数，返回0-1之间的小数</span><br><span class="line">SELECT RAND();</span><br></pre></td></tr></table></figure>
</li>
<li><p>日期函数具体案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.now:返回当前系统时间+日期</span><br><span class="line">SELECT NOW();</span><br><span class="line"></span><br><span class="line">#2.year:返回年</span><br><span class="line">SELECT YEAR(NOW());</span><br><span class="line">SELECT YEAR(hiredate) 年 FROM employees;</span><br><span class="line"></span><br><span class="line">#3.month:返回月</span><br><span class="line">#MONTHNAME:以英文形式返回月</span><br><span class="line">SELECT MONTH(NOW());</span><br><span class="line">SELECT MONTHNAME(NOW());</span><br><span class="line"></span><br><span class="line">#4.day:返回日</span><br><span class="line">#DATEDIFF:返回两个日期相差的天数</span><br><span class="line">SELECT DAY(NOW());</span><br><span class="line">SELECT DATEDIFF(&#39;2020&#x2F;06&#x2F;30&#39;,&#39;2020&#x2F;06&#x2F;21&#39;);</span><br><span class="line"></span><br><span class="line">#5.str_to_date:将字符通过指定格式转换成日期</span><br><span class="line">SELECT STR_TO_DATE(&#39;2020-5-13&#39;,&#39;%Y-%c-%d&#39;) AS out_put;</span><br><span class="line"></span><br><span class="line">#6.date_format:将日期转换成字符</span><br><span class="line">SELECT DATE_FORMAT(&#39;2020&#x2F;6&#x2F;6&#39;,&#39;%Y年%m月%d日&#39;) AS out_put;</span><br><span class="line">SELECT DATE_FORMAT(NOW(),&#39;%Y年%m月%d日&#39;) AS out_put;</span><br><span class="line"></span><br><span class="line">#7.curdate:返回当前日期</span><br><span class="line">SELECT CURDATE();</span><br><span class="line"></span><br><span class="line">#8.curtime:返回当前时间</span><br><span class="line">SELECT CURTIME();</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他函数具体案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#version 当前数据库服务器的版本</span><br><span class="line">SELECT VERSION();</span><br><span class="line"></span><br><span class="line">#database 当前打开的数据库</span><br><span class="line">SELECT DATABASE();</span><br><span class="line"></span><br><span class="line">#user当前用户</span><br><span class="line">SELECT USER();</span><br><span class="line"></span><br><span class="line">#password(&#39;字符&#39;)：返回该字符的密码形式</span><br><span class="line">SELECT PASSWORD(&#39;a&#39;);</span><br><span class="line"></span><br><span class="line">#md5(&#39;字符&#39;):返回该字符的md5加密形式</span><br><span class="line">SELECT MD5(&#39;a&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>流程控制函数具体案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.if函数: if else效果</span><br><span class="line"></span><br><span class="line">SELECT IF(10&lt;5,&#39;大&#39;,&#39;小&#39;);</span><br><span class="line"></span><br><span class="line">SELECT last_name,commission_pct,IF(commission_pct IS NULL,&#39;没奖金！！！&#39;,&#39;有奖金!!!&#39;) 备注 FROM employees;</span><br><span class="line"></span><br><span class="line">#2.case函数</span><br><span class="line">#使用一:switch case 的效果</span><br><span class="line">&#x2F;*</span><br><span class="line">java中</span><br><span class="line">switch(变量或表达式)&#123;</span><br><span class="line">	case 常量1:语句1;break;</span><br><span class="line">	...</span><br><span class="line">	default:语句n;break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql中</span><br><span class="line"></span><br><span class="line">case 要判断的变量或表达式</span><br><span class="line">when 常量1 then 要显示的值1或语句1</span><br><span class="line">when 常量2 then 要显示的值2或语句2</span><br><span class="line">...</span><br><span class="line">else 要显示的值n或语句n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">#案例:查询员工的工资,要求:</span><br><span class="line"></span><br><span class="line">部门号&#x3D;30,显示的工资为1.1倍</span><br><span class="line">部门号&#x3D;40,显示的工资为1.2倍</span><br><span class="line">部门号&#x3D;50,显示的工资为1.3倍</span><br><span class="line">其他部门,显示的工资为原工资</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">SELECT salary 原始工资,department_id,</span><br><span class="line">CASE department_id</span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN salary*1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END AS 新工资</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">#3.case函数的使用二:类似于多重if</span><br><span class="line">&#x2F;*</span><br><span class="line">java中:</span><br><span class="line">if(条件1)&#123;</span><br><span class="line">	语句1;</span><br><span class="line">&#125;else if(条件2)&#123;</span><br><span class="line">	语句2;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else&#123;</span><br><span class="line">	语句n;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">mysql中:</span><br><span class="line">case </span><br><span class="line">when 条件1 then 要显示的值1或语句1</span><br><span class="line">when 条件2 then 要显示的值2或语句2</span><br><span class="line">...</span><br><span class="line">else 要显示的值n或语句n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#案例:查询员工的工资的情况</span><br><span class="line">&#x2F;*</span><br><span class="line">如果工资&gt;20000，显示A级别</span><br><span class="line">如果工资&gt;15000，显示B级别</span><br><span class="line">如果工资&gt;10000，显示c级别</span><br><span class="line">否则，显示D级别</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">SELECT salary,</span><br><span class="line">CASE</span><br><span class="line">WHEN salary&gt;20000 THEN &#39;A&#39;</span><br><span class="line">WHEN salary&gt;15000 THEN &#39;B&#39;</span><br><span class="line">WHEN salary&gt;10000 THEN &#39;C&#39;</span><br><span class="line">ELSE &#39;D&#39;</span><br><span class="line">END AS 工资等级</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h4><ul>
<li><p>功能：用作统计使用，又称为聚合函数或统计函数或组函数</p>
</li>
<li><p>分类：sum 求和、avg 平均值、max 最大值、min最小值count 计算个数特点:</p>
<ul>
<li>sum和avg一般用于处理数值型<br>max、min、count可以处理任何数据类型</li>
<li>以上分组函数都忽略null</li>
<li>都可以搭配distinct使用，实现去重的统计<br>select sum(distinct 字段) from 表;</li>
<li>count函数<br>count(字段)：统计该字段非空值的个数<br>count(*):统计结果集的行数</li>
<li>和分组函数一同查询的字段，要求是group by后出现的字段</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.简单使用</span><br><span class="line">SELECT SUM(salary) FROM employees;</span><br><span class="line">SELECT AVG(salary) FROM employees;</span><br><span class="line">SELECT MAX(salary) FROM employees;</span><br><span class="line">SELECT MIN(salary) FROM employees;</span><br><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">#2.参数支持哪些数据类型</span><br><span class="line"></span><br><span class="line">SELECT SUM(last_name),AVG(last_name) FROM employees;</span><br><span class="line">SELECT SUM(hiredate),AVG(hiredate) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MAX(last_name),MIN(last_name) FROM employees;</span><br><span class="line">SELECT MAX(hiredate),MIN(hiredate) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(commission_pct) FROM employees;</span><br><span class="line">SELECT COUNT(last_name) FROM employees;</span><br><span class="line"></span><br><span class="line">#3.是否忽略null</span><br><span class="line"></span><br><span class="line">SELECT SUM(commission_pct),AVG(commission_pct) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT commission_pct FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT SUM(commission_pct),AVG(commission_pct),SUM(commission_pct)&#x2F;35,AVG(commission_pct)&#x2F;107 FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MAX(commission_pct),MIN(commission_pct) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(commission_pct) FROM employees;</span><br><span class="line"></span><br><span class="line">#4.和distinct搭配</span><br><span class="line"></span><br><span class="line">SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">#5.count函数详解</span><br><span class="line"></span><br><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line">SELECT COUNT(*) FROM employees;</span><br><span class="line">SELECT COUNT(1) FROM employees;</span><br><span class="line">&#x2F;*</span><br><span class="line">效率上：</span><br><span class="line">MyISAM存储引擎，count(*)最高</span><br><span class="line">InnoDB存储引擎，count(*)和count(1)效率&gt;count(字段)</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#6.和分组函数一同查询的字段有限制</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),employee_id FROM employees;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql5-DML数据操作语言+DDL数据定义语言</title>
    <url>/2021/05/17/MySql5/</url>
    <content><![CDATA[<h1 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h1><ul>
<li><p>插入：insert</p>
<p>修改：update</p>
<p>删除：delete</p>
<a id="more"></a>

</li>
</ul>
<h3 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h3><ul>
<li><p>方式一：经典的插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：insert into 表名(字段名,…)</span><br><span class="line">	 values(值,…);</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点</p>
<ul>
<li><p>要求值的类型和字段的类型要一致或兼容；</p>
</li>
<li><p>字段的个数和顺序不一定与原始表中的字段个数和顺序一致但必须保证值和字段一一对应；</p>
</li>
<li><p>假如表中有可以为null的字段，注意可以通过以下两种方式插入null值</p>
<ul>
<li>①字段和值都省略</li>
<li>②字段写上，值使用null</li>
</ul>
</li>
<li><p>字段和值的个数必须一致</p>
</li>
<li><p>字段名可以省略，默认所有列</p>
</li>
</ul>
</li>
<li><p>具体案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM beauty;</span><br><span class="line">#1.插入的值的类型要与列的类型一致或兼容</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);</span><br><span class="line"></span><br><span class="line">#2.不可以为null的列必须插入值。可以为null的列如何插入值？</span><br><span class="line">    #方法一：</span><br><span class="line">    INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">    VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);</span><br><span class="line"></span><br><span class="line">    #方法二：</span><br><span class="line">    INSERT INTO beauty(id,NAME,sex,phone)</span><br><span class="line">    VALUES(15,&#39;娜扎&#39;,&#39;女&#39;,&#39;1388888888&#39;);</span><br><span class="line"></span><br><span class="line">#3.列的顺序是否可以调换</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&#39;蒋欣&#39;,&#39;女&#39;,16,&#39;110&#39;);</span><br><span class="line"></span><br><span class="line">#4.列数和值的个数必须一致</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&#39;关晓彤&#39;,&#39;女&#39;,17,&#39;110&#39;);</span><br><span class="line"></span><br><span class="line">#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(18,&#39;张飞&#39;,&#39;男&#39;,NULL,&#39;119&#39;,NULL,NULL);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>方式二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：insert into 表名 </span><br><span class="line">	 set 列名&#x3D;值,列名&#x3D;值,…</span><br><span class="line"></span><br><span class="line">	INSERT INTO beauty </span><br><span class="line">	SET id&#x3D;19,NAME&#x3D;‘刘涛’,phone&#x3D;‘999’;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两种方式的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.方式一支持一次插入多行，语法如下：</span><br><span class="line">	insert into 表名【(字段名,..)】 values(值，..),(值，...),...;</span><br><span class="line">2.方式一支持子查询，语法如下：</span><br><span class="line">    insert into 表名 查询语句;</span><br><span class="line">    </span><br><span class="line">#1、方式一支持插入多行,方式二不支持</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(23,&#39;唐艺昕1&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)</span><br><span class="line">,(24,&#39;唐艺昕2&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)</span><br><span class="line">,(25,&#39;唐艺昕3&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);</span><br><span class="line"></span><br><span class="line">#2、方式一支持子查询，方式二不支持</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,phone) SELECT 26,&#39;宋茜&#39;,&#39;11809866&#39;;</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,phone) </span><br><span class="line">SELECT id,boyname,&#39;1234567&#39; FROM boys WHERE id&lt;3;       </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a>修改语句</h3><ul>
<li><p>修改单表的记录★</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：update 表名 </span><br><span class="line">	 set 列&#x3D;新值,列&#x3D;新值,… </span><br><span class="line">	 where 筛选条件;</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.修改单表的记录</span><br><span class="line">#案例1：修改beauty表中姓唐的女神的电话为13899888899</span><br><span class="line">UPDATE beauty SET phone &#x3D; &#39;13899888899&#39;</span><br><span class="line">WHERE NAME LIKE &#39;唐%&#39;;</span><br><span class="line"></span><br><span class="line">#案例2：修改boys表中id好为2的名称为张飞，魅力值 10</span><br><span class="line">UPDATE boys SET boyname&#x3D;&#39;张飞&#39;,usercp&#x3D;10</span><br><span class="line">WHERE id&#x3D;2;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><ul>
<li><p>方式一: delete</p>
</li>
<li><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、单表的删除【★】</span><br><span class="line">delete from 表名 where 筛选条件</span><br><span class="line"></span><br><span class="line">2、多表的删除【补充】</span><br><span class="line">sql92语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名,表2 别名</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line">sql99语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名</span><br><span class="line">inner|left|right join 表2 别名 on 连接条件</span><br><span class="line">where 筛选条件;mys</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.单表的删除</span><br><span class="line">#案例：删除手机号以9结尾的女神信息</span><br><span class="line">DELETE FROM beauty WHERE phone LIKE &#39;%9&#39;;</span><br><span class="line">SELECT * FROM beauty;</span><br><span class="line"></span><br><span class="line">#2.多表的删除</span><br><span class="line">#案例：删除张无忌的女朋友的信息</span><br><span class="line">DELETE b</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.&#96;boyfriend_id&#96; &#x3D; bo.&#96;id&#96;</span><br><span class="line">WHERE bo.&#96;boyName&#96;&#x3D;&#39;张无忌&#39;;</span><br><span class="line"></span><br><span class="line">#案例：删除黄晓明的信息以及他女朋友的信息</span><br><span class="line">DELETE b,bo</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.&#96;boyfriend_id&#96;&#x3D;bo.&#96;id&#96;</span><br><span class="line">WHERE bo.&#96;boyName&#96;&#x3D;&#39;黄晓明&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：truncate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：truncate table 表名;</span><br><span class="line"></span><br><span class="line">#案例：将魅力值&gt;100的男神信息删除</span><br><span class="line">TRUNCATE TABLE boys ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两种方式的区别【面试题】★</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">delete</span> 可以加<span class="keyword">where</span> 条件，<span class="keyword">truncate</span>不能加</span><br><span class="line"><span class="number">2.</span><span class="keyword">truncate</span>直接删除真个表，在创建一个空表，效率高，<span class="keyword">delete</span>只能一行一行删</span><br><span class="line"><span class="number">3.</span>假如要删除的表中有自增长列，</span><br><span class="line">  如果用<span class="keyword">delete</span>删除后，再插入数据，自增长列的值从断点开始，而<span class="keyword">truncate</span>删除后，再插入数据，自增长列的值从<span class="number">1</span>开始。</span><br><span class="line"><span class="number">4.</span><span class="keyword">truncate</span>删除没有返回值，<span class="keyword">delete</span>删除有返回值为删除的行数。</span><br><span class="line"><span class="number">5.</span><span class="keyword">truncate</span>删除不能回滚，<span class="keyword">delete</span>删除可以回滚找回数据.</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="DDL语言"><a href="#DDL语言" class="headerlink" title="DDL语言"></a>DDL语言</h1><h3 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h3><ul>
<li><p>创建库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database 【if not exists】 库名【 character set 字符集名】;</span><br><span class="line">#案例：创建库Books</span><br><span class="line">  CREATE DATABASE IF NOT EXISTS books ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database 库名 character set 字符集名;</span><br><span class="line">#案例：更改库的字符集</span><br><span class="line">ALTER DATABASE books CHARACTER SET gbk;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database 【if exists】 库名;</span><br><span class="line">#案例：库的删除</span><br><span class="line">DROP DATABASE IF EXISTS books;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h3><ul>
<li><p>表的创建 ★</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">语法：</span><br><span class="line">create table 表名(</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	...</span><br><span class="line">	列名 列的类型【(长度) 约束】</span><br><span class="line">)</span><br><span class="line">*&#x2F;</span><br><span class="line">#案例：创建表Book</span><br><span class="line">CREATE TABLE book (</span><br><span class="line">  id INT,</span><br><span class="line">  #编号</span><br><span class="line">  bName VARCHAR (20),</span><br><span class="line">  #图书名</span><br><span class="line">  price DOUBLE,</span><br><span class="line">  #价格</span><br><span class="line">  authorId INT,</span><br><span class="line">  #作者编号</span><br><span class="line">  publishDate DATETIME#出版日期</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">DESC book;</span><br><span class="line"></span><br><span class="line">#案例：创建表author</span><br><span class="line">CREATE TABLE IF NOT EXISTS author (</span><br><span class="line">  id INT,</span><br><span class="line">  au_n&#96;author&#96;ame VARCHAR (20),</span><br><span class="line">  nation VARCHAR (10)</span><br><span class="line">);</span><br><span class="line">DESC author ;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>表的修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.添加列</span><br><span class="line">alter table 表名 add column 列名 类型 【first|after 字段名】;</span><br><span class="line">2.修改列的类型或约束</span><br><span class="line">alter table 表名 modify column 列名 新类型 【新约束】;</span><br><span class="line">3.修改列名</span><br><span class="line">alter table 表名 change column 旧列名 新列名 类型;</span><br><span class="line">4 .删除列</span><br><span class="line">alter table 表名 drop column 列名;</span><br><span class="line">5.修改表名</span><br><span class="line">alter table 表名 rename 【to】 新表名;</span><br><span class="line"></span><br><span class="line">案例：</span><br><span class="line">#①修改列名</span><br><span class="line">ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME ;</span><br><span class="line"></span><br><span class="line">#②修改列的类型或约束</span><br><span class="line">ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;</span><br><span class="line"></span><br><span class="line">#③添加新列</span><br><span class="line">ALTER TABLE author ADD COLUMN annual DOUBLE; </span><br><span class="line"></span><br><span class="line">#④删除列</span><br><span class="line">ALTER TABLE book_author DROP COLUMN  annual;</span><br><span class="line"></span><br><span class="line">#⑤修改表名</span><br><span class="line">ALTER TABLE book_author RENAME TO author;</span><br><span class="line"></span><br><span class="line">DESC book;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表的删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table【if exists】 表名;</span><br><span class="line"></span><br><span class="line">案例：</span><br><span class="line">DROP TABLE IF EXISTS book_author;</span><br><span class="line"></span><br><span class="line">SHOW TABLES;</span><br><span class="line"></span><br><span class="line">#通用的写法：</span><br><span class="line">DROP DATABASE IF EXISTS 旧库名;</span><br><span class="line">CREATE DATABASE 新库名 ;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS 旧表名;</span><br><span class="line">CREATE TABLE  表名();</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><ul>
<li><p>分类：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tinyint</span>、smallint、mediumint、int/integer、bigint</span><br><span class="line"><span class="attribute">1</span>	       <span class="number">2</span>		   <span class="number">3</span>	       <span class="number">4</span>		 <span class="number">8</span>	字节</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：</p>
<ul>
<li><p>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字</p>
</li>
<li><p>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值</p>
</li>
<li><p>③ 如果不设置长度，会有默认的长度</p>
<p>​    长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</p>
</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.如何设置无符号和有符号</span><br><span class="line">DROP TABLE IF EXISTS tab_int ;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tab_int (t1 INT (7) ZEROFILL, t2 INT (7) ZEROFILL) ;&#x2F;&#x2F;zerofill不够左填充0</span><br><span class="line"></span><br><span class="line">DESC tab_int ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES (- 123456) ;&#x2F;&#x2F;超出范围 0000000</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES (- 123456, - 123456) ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES (2147483648, 4294967296) ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES (123, 123) ;&#x2F;&#x2F;0000123</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_int ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><ul>
<li><p>定点数：dec(M,D)；decimal(M,D)</p>
</li>
<li><p>浮点数：float(M,D) 4字节；double(M,D) 8字节</p>
</li>
<li><p>特点：</p>
<ul>
<li>①M代表整数部位+小数部位的个数，D代表小数部位</li>
<li>②如果超出范围，则报out or range异常，并且插入临界值</li>
<li>③M和D都可以省略，但对于定点数，M默认为10，D默认为0</li>
<li>④如果精度要求较高，则优先考虑使用定点数</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#测试M和D</span><br><span class="line">DROP TABLE tab_float ;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tab_float (f1 FLOAT, f2 DOUBLE, f3 DECIMAL) ;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_float ;</span><br><span class="line"></span><br><span class="line">DESC tab_float ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);&#x2F;&#x2F;decimal默认显示123</span><br><span class="line">INSERT INTO tab_float VALUES(123.456,123.456,123.456);</span><br><span class="line">INSERT INTO tab_float VALUES(123.4,123.4,123.4);</span><br><span class="line">INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);</span><br><span class="line"></span><br><span class="line">#原则：</span><br><span class="line">#所选择的类型越简单越好，能保存数值的类型越小越好</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><ul>
<li><p>较短的文本：char、varchar</p>
</li>
<li><p>其他：</p>
<ul>
<li>binary和varbinary用于保存较短的二进制</li>
<li>enum用于保存枚举</li>
<li>set用于保存集合</li>
</ul>
</li>
<li><p>较长的文本：text、blob(较大的二进制)</p>
</li>
<li><p>特点</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">  		  写法			  M的意思						特点		 空间的耗费	 效率</span><br><span class="line"><span class="type">char</span>	<span class="type">char</span>(M)		 最大的字符数，可以省略，默认为<span class="number">1</span>	  固定长度的字符	比较耗费	 高</span><br><span class="line"></span><br><span class="line"><span class="type">varchar</span>	<span class="type">varchar</span>(M)	 最大的字符数，不可以省略			可变长度的字符	  比较节省	   低</span><br><span class="line">若存&quot;abcd&quot;则<span class="type">char</span>[<span class="number">10</span>]除了abcd四个字符后面仍占空间六个空格，<span class="type">varchar</span>[<span class="number">10</span>]则只存abcd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_char(</span><br><span class="line">	c1 ENUM(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_char VALUES(&#39;a&#39;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;b&#39;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;c&#39;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;m&#39;);&#x2F;&#x2F;可以执行但为空</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;A&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_set;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tab_set(</span><br><span class="line">	s1 SET(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)</span><br><span class="line">);</span><br><span class="line">INSERT INTO tab_set VALUES(&#39;a&#39;);</span><br><span class="line">INSERT INTO tab_set VALUES(&#39;A,B&#39;);</span><br><span class="line">INSERT INTO tab_set VALUES(&#39;a,c,d&#39;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="日期型"><a href="#日期型" class="headerlink" title="日期型"></a>日期型</h4><ul>
<li><p>分类：</p>
<ul>
<li>date只保存日期；</li>
<li>time 只保存时间；</li>
<li>year只保存年；</li>
<li>datetime保存日期+时间；</li>
<li>timestamp保存日期+时间；</li>
</ul>
</li>
<li><p>特点</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">			字节		范围			时区等的影响</span><br><span class="line">datetime	 <span class="number">8</span>		<span class="number">1000</span>——<span class="number">9999</span>	       不受</span><br><span class="line"><span class="type">timestamp</span>	 <span class="number">4</span>	    <span class="number">1970</span><span class="number">-2038</span>	        受</span><br><span class="line">更多用<span class="type">timestamp</span>，占空间小</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tab_date(</span><br><span class="line">	t1 DATETIME,</span><br><span class="line">	t2 TIMESTAMP</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_date VALUES(NOW(),NOW());</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_date;</span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &#39;time_zone&#39;;</span><br><span class="line"></span><br><span class="line">SET time_zone&#x3D;&#39;+9:00&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql2-DQL数据查询语言前五项</title>
    <url>/2021/05/16/MySql2/</url>
    <content><![CDATA[<p><img src="/2021/05/16/MySql2/1.png"></p>
<a id="more"></a>

<h1 id="DQL语言"><a href="#DQL语言" class="headerlink" title="DQL语言"></a>DQL语言</h1><h2 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h2><ul>
<li><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表 from 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类似于System.out.println(打印东西);</p>
</li>
<li><p>特点：</p>
<ul>
<li>1.查询列表可以是：表中的字段、常量值、表达式、函数</li>
<li>2.查询的结果可以是一个虚拟表格;</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line">#1.查询表中的单个字段</span><br><span class="line">SELECT last_name FROM employees;</span><br><span class="line"></span><br><span class="line">#2.查询表中多个字段</span><br><span class="line">SELECT last_name,salary,email FROM employees;</span><br><span class="line"></span><br><span class="line">#3.查询表中的所有字段</span><br><span class="line">SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">#4.查询常量</span><br><span class="line"># select 常量值;</span><br><span class="line"># 注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要</span><br><span class="line">SELECT 100;</span><br><span class="line">SELECT &#39;join&#39;;</span><br><span class="line"></span><br><span class="line">#5.查询函数</span><br><span class="line">#select 函数名(实参列表);</span><br><span class="line">SELECT VERSION();</span><br><span class="line"></span><br><span class="line">#6.查询表达式 </span><br><span class="line">SELECT 100%98;</span><br><span class="line"></span><br><span class="line">#7.起别名</span><br><span class="line">&#x2F;*</span><br><span class="line">1.便于理解</span><br><span class="line">2.如果要查询的字段有重名的情况,使用别名区分</span><br><span class="line">*&#x2F;</span><br><span class="line">#方式一:使用AS</span><br><span class="line">SELECT 100%98 AS 结果;</span><br><span class="line">SELECT last_name AS 姓,first_name AS 名 FROM employees;</span><br><span class="line"></span><br><span class="line">#方式二:使用空格</span><br><span class="line">SELECT last_name 姓,first_name 名 FROM employees;</span><br><span class="line"></span><br><span class="line">#案例:查询salary,结果显示 out put</span><br><span class="line">SELECT salary AS &quot;out put&quot; FROM employees;</span><br><span class="line"></span><br><span class="line">#8.去重</span><br><span class="line"># select distinct 字段名 from 表名;</span><br><span class="line">#案例:查询员工表中涉及的所有部门编号</span><br><span class="line">SELECT DISTINCT department_id FROM employees;</span><br><span class="line"></span><br><span class="line">#9.+号的作用</span><br><span class="line">#案例:查询员工的名和姓,并显示为姓名</span><br><span class="line">&#x2F;*</span><br><span class="line">java中的+号:</span><br><span class="line">1.运算符:两个操作数都为数据型</span><br><span class="line">2.连接符:只要有一个操作数为字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql中的+号:</span><br><span class="line">只能作为运算符</span><br><span class="line"></span><br><span class="line">select 100+90; 两个操作数都为数值型,做加法运算</span><br><span class="line">select &#39;123+90&#39;;其中一方为字符型,试图将字符型数值转换为数值型</span><br><span class="line">		如果转换成功,则继续做加法运算</span><br><span class="line">select &#39;john&#39;+90; 如果转换失败,则将字符型数值转换成0</span><br><span class="line"></span><br><span class="line">select null+0; 只要其中一方为null,则结果肯定为null.</span><br><span class="line">*&#x2F;</span><br><span class="line">SELECT last_name+first_name AS 姓名 FROM employees; </span><br><span class="line"></span><br><span class="line">#10.【补充】concat函数 </span><br><span class="line">&#x2F;*</span><br><span class="line">功能：拼接字符</span><br><span class="line">select concat(字符1，字符2，字符3,...);</span><br><span class="line">*&#x2F;</span><br><span class="line">SELECT CONCAT(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) AS 结果 FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT CONCAT(last_name,first_name) AS 姓名 FROM employees;</span><br><span class="line"></span><br><span class="line">#11.【补充】ifnull函数</span><br><span class="line">#功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值</span><br><span class="line"></span><br><span class="line">SELECT IFNULL(commission_pct,0) FROM employees;</span><br><span class="line"></span><br><span class="line">#12.【补充】isnull函数</span><br><span class="line">#功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><ul>
<li><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表 from 表名 where 筛选条件;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、按条件表达式筛选</span><br><span class="line">	条件运算符:&gt; &lt; &#x3D; !&#x3D; &lt;&gt; &gt;&#x3D; &lt;&#x3D; &lt;&#x3D;&gt;安全等于</span><br><span class="line">二、按逻辑表达式筛选</span><br><span class="line">	逻辑运算符:&amp;&amp; || |</span><br><span class="line">	and or not</span><br><span class="line">	</span><br><span class="line">	&amp;&amp; 和 and:两个条件都为true，结果为true，反之为false</span><br><span class="line">	|| 和 or:只要有一个条件为true，结果为true，反之为false</span><br><span class="line">	! 或 not:如果连接的条件本身为false，结果为true，反之为false	</span><br><span class="line">	</span><br><span class="line">三、模糊查询</span><br><span class="line">	like:一般搭配通配符使用，可以判断字符型或数值型</span><br><span class="line">	通配符：%任意多个字符，_任意单个字符</span><br><span class="line">	like、between and、in、is null</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一.按条件表达式筛选</span><br><span class="line"></span><br><span class="line">#案例1:查询工资&gt;12000的员工信息</span><br><span class="line">SELECT * FROM employees WHERE salary&gt;12000;</span><br><span class="line"></span><br><span class="line">#案例2:查询部门编号不等于90号的员工名和部门编号</span><br><span class="line">SELECT last_name,department_id FROM employees WHERE department_id &lt;&gt; 90;</span><br><span class="line"></span><br><span class="line">#二、按逻辑表达式筛选</span><br><span class="line"></span><br><span class="line">#案例1:查询工资z在10000到20000之间的员工名、工资及奖金</span><br><span class="line">SELECT last_name,salary,commission_pct FROM employees WHERE salary&gt;&#x3D;10000 AND salary&lt;&#x3D;20000;</span><br><span class="line"></span><br><span class="line">#案例2:查询部门编号不是在90-110之间,或者工资高于15000的员工信息</span><br><span class="line">SELECT * FROM employees WHERE department_id &lt;90 OR department_id&gt;110 OR salary&gt;15000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#三、模糊查询</span><br><span class="line"></span><br><span class="line">#1.like</span><br><span class="line"></span><br><span class="line">#案例1:查询员工名中包含字符a的员工信息</span><br><span class="line">SELECT * FROM employees WHERE last_name LIKE &#39;%a%&#39;;</span><br><span class="line"></span><br><span class="line">#案例2:查询员工名中第三个字符为b，第五个字符为a的员工名和工资</span><br><span class="line">SELECT last_name,salary FROM employees WHERE last_name LIKE &#39;__b_a%&#39;;</span><br><span class="line"></span><br><span class="line">#案例3:查询员工名种第二个字符为_的员工名</span><br><span class="line">SELECT last_name FROM employees WHERE last_name LIKE &#39;_\_%&#39;;</span><br><span class="line"></span><br><span class="line">#2.between and</span><br><span class="line"></span><br><span class="line">#案例1:查询员工编号在100到120之间的员工信息</span><br><span class="line">SELECT * FROM employees WHERE employee_id&gt;&#x3D;100 AND employee_id&lt;&#x3D;120;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees WHERE employee_id BETWEEN 100 AND 120;</span><br><span class="line"></span><br><span class="line">&#x2F;*注意事项：</span><br><span class="line">1.提高语句简洁度</span><br><span class="line">2.包含临界值</span><br><span class="line">3.两个临界值不能调换顺序</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#3.in</span><br><span class="line">&#x2F;*</span><br><span class="line">含义:判断某字段的值是否属于in列表中的某一项</span><br><span class="line">特点:</span><br><span class="line"> 1.使用in提高语句简洁度</span><br><span class="line"> 2.in列表的值类型必须一致或兼容</span><br><span class="line">*&#x2F;</span><br><span class="line">#案例1:查询员工的工种编号是IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id FROM employees WHERE job_id&#x3D;&#39;IT_PROG&#39; OR job_id&#x3D;&#39;AD_PRES&#39; OR job_id&#x3D;&#39;AD_VP&#39;;</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_id FROM employees WHERE job_id IN(&#39;IT_PROG&#39;,&#39;AD_PRES&#39;,&#39;AD_VP&#39;);</span><br><span class="line"></span><br><span class="line">#4.is null</span><br><span class="line">&#x2F;*</span><br><span class="line">&#x3D;或&lt;&gt;不能用于判断null值</span><br><span class="line">is null 或 is not null 可以判断null值</span><br><span class="line">*&#x2F;</span><br><span class="line">#案例1:查询没有奖金的员工名和奖金率</span><br><span class="line"></span><br><span class="line">SELECT last_name,commission_pct FROM employees WHERE commission_pct IS NULL;</span><br><span class="line"></span><br><span class="line">SELECT last_name,commission_pct FROM employees WHERE commission_pct IS NOT NULL;</span><br><span class="line"></span><br><span class="line">#安全等于&lt;&#x3D;&gt;</span><br><span class="line"></span><br><span class="line">#案例1:查询没有奖金的员工名和奖金率</span><br><span class="line"></span><br><span class="line">SELECT last_name,commission_pct FROM employees WHERE commission_pct &lt;&#x3D;&gt; NULL;</span><br><span class="line"></span><br><span class="line">#案例2:查询工资为12000的员工信息</span><br><span class="line">SELECT last_name,commission_pct FROM employees WHERE salary &lt;&#x3D;&gt; 12000;</span><br><span class="line"></span><br><span class="line">#is null PK &lt;&#x3D;&gt;</span><br><span class="line">#	      普通类型的数值	null值		可读性</span><br><span class="line"># is null	×		  	  √		      √</span><br><span class="line"># &lt;&#x3D;&gt;		√		 	  √		      ×</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><ul>
<li><p>引入：select * from employees;</p>
</li>
<li><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 查询列表 from 表 【where 筛选条件】 order by</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：</p>
<p>1.asc代表的是升序，desc代表降序，不写默认为升序<br>2.order by子句中可以支持单个字段、多个字段、表达式、函数、别名<br>3.order by子句一般是放在查询语句的最后面,limit子句除外</p>
</li>
</ul>
<ul>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例1:查询员工信息,要求工资从高到低排序</span><br><span class="line">SELECT * FROM employees ORDER BY salary DESC;</span><br><span class="line">SELECT * FROM employees ORDER BY salary;</span><br><span class="line"></span><br><span class="line">#案例2:查询部门编号是&gt;&#x3D;90，按入职时间的先后进行排序</span><br><span class="line">SELECT * FROM employees WHERE department_id&gt;&#x3D;90 ORDER BY hiredate ASC;</span><br><span class="line"></span><br><span class="line">#案例3:按年薪的高低显示员工的信息和年薪【按表达式排序】</span><br><span class="line">SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employees </span><br><span class="line">ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC; </span><br><span class="line"></span><br><span class="line">#案例4:按年薪的高低显示员工的信息和年薪【按别名排序】</span><br><span class="line">SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employees </span><br><span class="line">ORDER BY salary*12*(1+IFNULL(commission_pct,0)) 年薪 DESC;</span><br><span class="line"></span><br><span class="line">#案例5:按姓名的长度显示员工的姓名和工资【按函数排序】</span><br><span class="line">SELECT LENGTH(last_name) 字节长度,last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">ORDER BY LENGTH(last_name) DESC;</span><br><span class="line"></span><br><span class="line">#案例6:查询员工共信息,要求按工资排序，再按员工编号排序【按多个字段排序】</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">ORDER BY salary ASC,employee_id DESC;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><ul>
<li><p>语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 分组函数,分组后的字段</span><br><span class="line">from 表</span><br><span class="line">【where 筛选条件】</span><br><span class="line">group by 分组的字段</span><br><span class="line">【having 分组后的筛选】</span><br><span class="line">【order by 排序列表】</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意:查询列表必须特殊,要求是分组函数和group by后出现的字段</p>
</li>
<li><p>特点:</p>
<ul>
<li><p>分组查询中的筛选条件分为两类</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">			使用关键字	筛选的表	位置</span><br><span class="line">分组前筛选	<span class="keyword">where</span>		原始表		<span class="keyword">group</span> <span class="keyword">by</span>的前面</span><br><span class="line">分组后筛选	<span class="keyword">having</span>		分组后的结果	<span class="keyword">group</span> <span class="keyword">by</span>的后面</span><br><span class="line"><span class="number">1.</span>分组函数做条件肯定是放在<span class="keyword">having</span>子句中</span><br><span class="line"><span class="number">2.</span>能用分组前筛选的，就优先考虑使用分组前筛选</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>2.group by子句支持单个字段分组，多个字段分组(多个字段之间用逗号隔开没有顺序要求),表达式或函数(使用较少)</li>
<li>3.也可以添加排序(排序放在整个分组查询的最后)</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#引入:查询每个部门的平均工资</span><br><span class="line">SELECT AVG(salary) FROM employees;</span><br><span class="line"></span><br><span class="line">#案例1:查询每个工种的最高工资</span><br><span class="line">SELECT MAX(salary),job_id FROM employees </span><br><span class="line">GROUP BY job_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2:查询每个位置上的部门个数</span><br><span class="line">SELECT COUNT(*),location_id</span><br><span class="line">FROM departments</span><br><span class="line">GROUP BY location_id;</span><br><span class="line"></span><br><span class="line">#添加筛选条件</span><br><span class="line">#案例1:查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class="line">SELECT AVG(salary),department_id FROM employees</span><br><span class="line">WHERE email LIKE &#39;%a%&#39; GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">#案例2:查询有奖金的每个领导手下员工的最高工资</span><br><span class="line">SELECT MAX(salary),manager_id FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br><span class="line"></span><br><span class="line">#添加复杂的筛选条件</span><br><span class="line">#案例1:查询哪个部门的员工个数&gt;2</span><br><span class="line">#1.查询每个部门的员工个数</span><br><span class="line">SELECT COUNT(*),department_id FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">#2.根据1的结果进行筛选，查询哪个部门的员工个数大于2</span><br><span class="line">SELECT COUNT(*),department_id FROM employees</span><br><span class="line">GROUP BY department_id HAVING COUNT(*)&gt;2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2:查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资 </span><br><span class="line">#1.查询每个工种有奖金的员工的最高工资 </span><br><span class="line">SELECT MAX(salary),job_id FROM employees </span><br><span class="line">WHERE commission_pct IS NOT NULL GROUP BY job_id; </span><br><span class="line"></span><br><span class="line">#2.根据结果继续筛选，最高工资&gt;12000 </span><br><span class="line"></span><br><span class="line">SELECT MAX(salary), job_id FROM employees </span><br><span class="line">WHERE commission_pct IS NOT NULL GROUP BY job_id </span><br><span class="line">HAVING MAX(salary)&gt;12000; </span><br><span class="line"></span><br><span class="line">#按表达式或函数分组</span><br><span class="line"></span><br><span class="line">#案例:按员工姓名的长度分组,查询每一组的员工个数,筛选员工个数&gt;5</span><br><span class="line"></span><br><span class="line">#1.查询每个长度的员工个数 </span><br><span class="line">SELECT COUNT(*),LENGTH(last_name) len_name </span><br><span class="line">FROM employees GROUP BY LENGTH(last_name); </span><br><span class="line"></span><br><span class="line">#2.添加筛选条件</span><br><span class="line">SELECT COUNT(*) c,LENGTH(last_name) len_name </span><br><span class="line">FROM employees GROUP BY len_name HAVING c&gt;5;</span><br><span class="line"></span><br><span class="line">#按多个字段查询</span><br><span class="line">#案例:查询每个部门每个工种的员工的平均工资</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),department_id,job_id</span><br><span class="line">FROM employees GROUP BY department_id,job_id;</span><br><span class="line"></span><br><span class="line">#添加排序</span><br><span class="line">#案例:查询每个部门每个工种的员工的平均工资,按平均工资的高低查询</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary),department_id,job_id</span><br><span class="line">FROM employees GROUP BY department_id,job_id</span><br><span class="line">ORDER BY AVG(salary) DESC;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>myfirstblog</title>
    <url>/2020/12/03/myfirstblog/</url>
    <content><![CDATA[<p>##第一章</p>
<h3 id="qq截图-平时加长截图效果不错"><a href="#qq截图-平时加长截图效果不错" class="headerlink" title="qq截图    平时加长截图效果不错"></a>qq截图    平时加长截图效果不错</h3><h3 id="chrome-F12-ctrl-shift-p-full-效果一般"><a href="#chrome-F12-ctrl-shift-p-full-效果一般" class="headerlink" title="chrome    F12    ctrl+shift+p   full    效果一般"></a>chrome    F12    ctrl+shift+p   full    效果一般</h3><a id="more"></a>

<h3 id="IE-网页捕获-效果还好"><a href="#IE-网页捕获-效果还好" class="headerlink" title="IE    网页捕获    效果还好"></a>IE    网页捕获    效果还好</h3><hr>
<p>##第二章</p>
<p>dd</p>
<!--more-->

<hr>
<p><a href="http://www.gewen54.cn/">www.gewen54.cn</a></p>
]]></content>
  </entry>
  <entry>
    <title>MySql6-DDL数据定义语言+TCL事务控制语言</title>
    <url>/2021/05/17/MySql6/</url>
    <content><![CDATA[<h1 id="DDL语言"><a href="#DDL语言" class="headerlink" title="DDL语言"></a>DDL语言</h1><h2 id="常见的约束"><a href="#常见的约束" class="headerlink" title="常见的约束"></a>常见的约束</h2><ul>
<li><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性。</p>
</li>
<li><p>分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">六大约束</span><br><span class="line">	NOT NULL：非空，用于保证该字段的值不能为空</span><br><span class="line">	比如姓名、学号等</span><br><span class="line">	DEFAULT:默认，用于保证该字段有默认值</span><br><span class="line">	比如性别</span><br><span class="line">	PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空</span><br><span class="line">	比如学号、员工编号等</span><br><span class="line">	UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空</span><br><span class="line">	比如座位号</span><br><span class="line">	CHECK:检查约束【mysql中不支持】</span><br><span class="line">	比如年龄、性别</span><br><span class="line">	FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</span><br><span class="line">		在从表添加外键约束，用于引用主表中某列的值</span><br><span class="line">	比如学生表的专业编号，员工表的部门编号，员工表的工种编号</span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>

<ul>
<li><p>添加约束的时机：1.创建表时；2.修改表时</p>
</li>
<li><p>约束的添加分类：</p>
<ul>
<li>列级约束：六大约束语法上都支持，但外键约束没有效果(mysql中非空、默认、主键、唯一)</li>
<li>表级约束：除了非空、默认，其他的都支持（mysql中主键、唯一、外键）</li>
</ul>
</li>
<li><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  CREATE TABLE 表名&#123;</span><br><span class="line">  	字段名 字段类型 列级约束,</span><br><span class="line">  	字段名 字段类型,</span><br><span class="line">  	表级约束</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">### 创建表时添加约束</span><br><span class="line"></span><br><span class="line">#### 添加列级约束</span><br><span class="line"></span><br><span class="line">- 语法：直接在字段名和类型后面追加 约束类型即可。只支持：默认、非空、主键、唯一</span><br><span class="line"></span><br><span class="line">- 案例</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  USE students;</span><br><span class="line">  </span><br><span class="line">  DROP TABLE stuinfo;</span><br><span class="line">  </span><br><span class="line">  CREATE TABLE stuinfo(</span><br><span class="line">  	id INT PRIMARY KEY,#主键</span><br><span class="line">  	stuName VARCHAR(20) NOT NULL UNIQUE,#非空</span><br><span class="line">  	gender CHAR(1) CHECK(gender&#x3D;&#39;男&#39; OR gender &#x3D;&#39;女&#39;),#检查</span><br><span class="line">  	seat INT UNIQUE,#唯一</span><br><span class="line">  	age INT DEFAULT  18,#默认约束</span><br><span class="line">  	majorId INT REFERENCES major(id)#外键</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  CREATE TABLE major(</span><br><span class="line">  	id INT PRIMARY KEY,</span><br><span class="line">  	majorName VARCHAR(20)</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  #查看stuinfo中的所有索引，包括主键、外键、唯一</span><br><span class="line">  SHOW INDEX FROM stuinfo;</span><br><span class="line"></span><br><span class="line">#### 添加表级约束</span><br><span class="line"></span><br><span class="line">- 语法：在各个字段的最下面 【constraint 约束名】 约束类型(字段名)</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  TABLE IF EXISTS stuinfo;</span><br><span class="line">  CREATE TABLE stuinfo(</span><br><span class="line">  	id INT,</span><br><span class="line">  	stuname VARCHAR(20),</span><br><span class="line">  	gender CHAR(1),</span><br><span class="line">  	seat INT,</span><br><span class="line">  	age INT,</span><br><span class="line">  	majorid INT,</span><br><span class="line">  	</span><br><span class="line">  	CONSTRAINT pk PRIMARY KEY(id),#主键</span><br><span class="line">  	CONSTRAINT uq UNIQUE(seat),#唯一键</span><br><span class="line">  	CONSTRAINT ck CHECK(gender &#x3D;&#39;男&#39; OR gender  &#x3D; &#39;女&#39;),#检查</span><br><span class="line">  	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键	</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  SHOW INDEX FROM stuinfo;</span><br><span class="line"></span><br><span class="line">- 通用的写法：★</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">  	id INT PRIMARY KEY,</span><br><span class="line">  	stuname VARCHAR(20),</span><br><span class="line">  	sex CHAR(1),</span><br><span class="line">  	age INT DEFAULT 18,</span><br><span class="line">  	seat INT UNIQUE,</span><br><span class="line">  	majorid INT,</span><br><span class="line">  	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  create table 表名(</span><br><span class="line">    	字段名 字段类型 not null,#非空</span><br><span class="line">    	字段名 字段类型 primary key,#主键</span><br><span class="line">    	字段名 字段类型 unique,#唯一</span><br><span class="line">    	字段名 字段类型 default 值,#默认</span><br><span class="line">    	constraint 约束名 foreign key(字段名) references 主表（被引用列）</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  注意：</span><br><span class="line">    			   支持类型		      可以起约束名			</span><br><span class="line">  列级约束		除了外键		     不可以</span><br><span class="line">  表级约束		除了非空和默认	  可以，但对主键无效</span><br><span class="line">    </span><br><span class="line">  列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</span><br><span class="line"></span><br><span class="line">- 主键和唯一的区别</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  		保证唯一性  是否允许为空    一个表中可以有多少个   	   是否允许组合</span><br><span class="line">  主键		√			×			至多有1个          		 √，但不推荐</span><br><span class="line">  唯一		√			√			可以有多个          		√，但不推荐</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 修改表时添加约束</span><br><span class="line"></span><br><span class="line">- 语法</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  1、添加列级约束</span><br><span class="line">  alter table 表名 modify column 字段名 字段类型 新约束;</span><br><span class="line">  </span><br><span class="line">  2、添加表级约束</span><br><span class="line">  alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</span><br><span class="line"></span><br><span class="line">- 案例</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">  CREATE TABLE stuinfo(</span><br><span class="line">  	id INT,</span><br><span class="line">  	stuname VARCHAR(20),</span><br><span class="line">  	gender CHAR(1),</span><br><span class="line">  	seat INT,</span><br><span class="line">  	age INT,</span><br><span class="line">  	majorid INT</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  DESC stuinfo;</span><br><span class="line">  #1.添加非空约束</span><br><span class="line">  ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;</span><br><span class="line">  </span><br><span class="line">  #2.添加默认约束</span><br><span class="line">  ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;</span><br><span class="line">  </span><br><span class="line">  #3.添加主键</span><br><span class="line">      #①列级约束</span><br><span class="line">      ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;</span><br><span class="line">      #②表级约束</span><br><span class="line">      ALTER TABLE stuinfo ADD PRIMARY KEY(id);</span><br><span class="line">  </span><br><span class="line">  #4.添加唯一</span><br><span class="line">      #①列级约束</span><br><span class="line">      ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;</span><br><span class="line">      #②表级约束</span><br><span class="line">      ALTER TABLE stuinfo ADD UNIQUE(seat);</span><br><span class="line">  </span><br><span class="line">  #5.添加外键</span><br><span class="line">  ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); </span><br><span class="line"></span><br><span class="line">### 修改表时删除约束</span><br><span class="line"></span><br><span class="line">* 案例</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  #1.删除非空约束</span><br><span class="line">  ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20);</span><br><span class="line">  </span><br><span class="line">  #2.删除默认约束</span><br><span class="line">  ALTER TABLE stuinfo MODIFY COLUMN age INT ;</span><br><span class="line">  </span><br><span class="line">  #3.删除主键</span><br><span class="line">  ALTER TABLE stuinfo DROP PRIMARY KEY;</span><br><span class="line">  </span><br><span class="line">  #4.删除唯一</span><br><span class="line">  ALTER TABLE stuinfo DROP INDEX seat;</span><br><span class="line">  </span><br><span class="line">  #5.删除外键</span><br><span class="line">  ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;</span><br><span class="line">  </span><br><span class="line">  SHOW INDEX FROM stuinfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 自增长列(标识列)</span><br><span class="line"></span><br><span class="line">- 含义：可以不用手动的插入值，系统提供默认的序列值</span><br><span class="line"></span><br><span class="line">- 特点</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  1.不用手动插入值，可以自动提供序列值，默认从1开始，步长为1</span><br><span class="line">    auto_increment_increment</span><br><span class="line">    如果要更改起始值：手动插入值 即插入的第一个值为起始值</span><br><span class="line">    如果要更改步长：更改系统变量</span><br><span class="line">    set auto_increment_increment &#x3D; 值;</span><br><span class="line">  2.一个表至多有一个自增长列</span><br><span class="line">  3.自增长列只能支持数值型</span><br><span class="line">  4.自增长列必须为一个key</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、创建表时设置标识列</span><br><span class="line">DROP TABLE IF EXISTS tab_identity;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tab_identity(</span><br><span class="line">	id INT  ,</span><br><span class="line">	NAME FLOAT UNIQUE AUTO_INCREMENT,</span><br><span class="line">	seat INT </span><br><span class="line">) TRUNCATE TABLE tab_identity;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_identity(id,NAME) VALUES(NULL,&#39;john&#39;);&#x2F;&#x2F;null也显示数字</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_identity(NAME) VALUES(&#39;lucy&#39;);&#x2F;&#x2F;也显示数字自增</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_identity;</span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &#39;%auto_increment%&#39;;</span><br><span class="line"></span><br><span class="line">SET auto_increment_increment&#x3D;3;</span><br></pre></td></tr></table></figure>
</li>
<li><p>语法总结</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、创建表时设置自增长列</span><br><span class="line">create table 表(</span><br><span class="line">	字段名 字段类型 约束 auto_increment</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">二、修改表时设置自增长列</span><br><span class="line">alter table 表 modify column 字段名 字段类型 约束 auto_increment;</span><br><span class="line"></span><br><span class="line">三、删除自增长列</span><br><span class="line">alter table 表 modify column 字段名 字段类型 约束;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="TCL语言"><a href="#TCL语言" class="headerlink" title="TCL语言"></a>TCL语言</h1><ul>
<li><p>事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">案例：转账</span><br><span class="line"></span><br><span class="line">张三丰  1000</span><br><span class="line">郭襄	1000</span><br><span class="line"></span><br><span class="line">update 表 set 张三丰的余额&#x3D;500 where name&#x3D;&#39;张三丰&#39;</span><br><span class="line">意外</span><br><span class="line">update 表 set 郭襄的余额&#x3D;1500 where name&#x3D;&#39;郭襄&#39;</span><br><span class="line">&#x2F;&#x2F;所以要保证两项都执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务的使用步骤 ★</p>
<ul>
<li><p>隐式（自动）事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete</p>
</li>
<li><p>显式事务：事务具有明显的开启和结束的标记；前提：必须先设置自动提交功能为禁用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启事务的语句;</span><br><span class="line">update 表 set 张三丰的余额&#x3D;500 where name&#x3D;&#39;张三丰&#39;</span><br><span class="line"></span><br><span class="line">update 表 set 郭襄的余额&#x3D;1500 where name&#x3D;&#39;郭襄&#39; </span><br><span class="line">结束事务的语句;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>具体步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">步骤1：开启事务</span><br><span class="line">set autocommit&#x3D;0;</span><br><span class="line">start transaction;可选的</span><br><span class="line"></span><br><span class="line">步骤2：编写事务中的sql语句(select insert update delete)</span><br><span class="line">语句1;</span><br><span class="line">语句2;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">步骤3：结束事务</span><br><span class="line">commit;提交事务</span><br><span class="line">rollback;回滚事务</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;autocommit&#39;;</span><br><span class="line">SHOW ENGINES;</span><br><span class="line"></span><br><span class="line">#1.演示事务的使用步骤</span><br><span class="line">DROP TABLE IF EXISTS account;</span><br><span class="line">CREATE TABLE account(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	username VARCHAR(20),</span><br><span class="line">	balance DOUBLE</span><br><span class="line">);</span><br><span class="line">INSERT INTO account(username,balance)</span><br><span class="line">VALUES(&#39;张无忌&#39;,1000),(&#39;赵敏&#39;,1000);</span><br><span class="line"></span><br><span class="line">#开启事务</span><br><span class="line">SET autocommit&#x3D;0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">#编写一组事务的语句</span><br><span class="line">UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;张无忌&#39;;</span><br><span class="line">UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;赵敏&#39;;</span><br><span class="line"></span><br><span class="line">#结束事务</span><br><span class="line">ROLLBACK;</span><br><span class="line">#commit;</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并发事务</p>
<ul>
<li><p>事务的并发问题是如何发生的？</p>
<p>​    多个事务同时操作 同一个数据库的相同数据时</p>
</li>
<li><p>并发问题都有哪些？</p>
<p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题：</p>
<ul>
<li>脏读：一个事务读取了其他事务还没有提交的数据，实际读到的是其他事务在中途更改的数据；</li>
<li>不可重复读：一个事务多次读取，结果不一样；</li>
<li>幻读：一个事务读取了其他事务还没有提交的数据，实际读到的是其他事务中途插入的数据。</li>
</ul>
</li>
</ul>
<p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.</p>
<p>一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱</p>
<ul>
<li><p>如何解决并发问题？</p>
<ul>
<li>通过设置隔离级别来解决并发问题</li>
</ul>
</li>
<li><p>隔离级别</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">							脏读			不可重复读		  幻读       ×是不能解决</span><br><span class="line"><span class="keyword">read</span> <span class="keyword">uncommitted</span>:读未提交     ×                ×              ×       √是可以解决</span><br><span class="line"><span class="keyword">read</span> <span class="keyword">committed</span>：读已提交      √                ×              ×</span><br><span class="line"><span class="keyword">repeatable</span> <span class="keyword">read</span>：可重复读     √                √              ×</span><br><span class="line"><span class="keyword">serializable</span>：串行化          √                √              √</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Oracle 支持的2 种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED</p>
<p>Mysql 支持4 种事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">设置隔离级别</span><br><span class="line">set session|global transaction isolation level 隔离级别;</span><br><span class="line"></span><br><span class="line">#2.演示事务对于delete和truncate的处理的区别</span><br><span class="line">SET autocommit&#x3D;0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">DELETE FROM account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回滚点savepoint的演示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">演示savepoint 的使用</span><br><span class="line">SET autocommit&#x3D;0;</span><br><span class="line"></span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM account WHERE id&#x3D;25;</span><br><span class="line">SAVEPOINT a;#设置保存点</span><br><span class="line">DELETE FROM account WHERE id&#x3D;28;</span><br><span class="line">ROLLBACK TO a;#回滚到保存点</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树创建与遍历</title>
    <url>/2021/03/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">premidpost</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一颗二叉树</span></span><br><span class="line">        BinaryTree1 binaryTree1 = <span class="keyword">new</span> BinaryTree1();</span><br><span class="line">        <span class="comment">//创建需要的结点</span></span><br><span class="line">        Node root = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="string">&quot;curry&quot;</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="string">&quot;james&quot;</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="string">&quot;durant&quot;</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="string">&quot;lillard&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动创建二叉树，之后递归方式</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        binaryTree1.setRoot(root);<span class="comment">//把建立的二叉树给binarytree</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        binaryTree1.preOrder();<span class="comment">//1,2,3,4顺序</span></span><br><span class="line">        binaryTree1.midOrder();<span class="comment">//2,1,3,4顺序</span></span><br><span class="line">        binaryTree1.postOrder();<span class="comment">//2，4，3，1顺序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加结点</span></span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">5</span>, <span class="string">&quot;hardon&quot;</span>);</span><br><span class="line">        node3.setLeft(node5);</span><br><span class="line">        binaryTree1.postOrder();<span class="comment">//25431</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义二叉树 包含根节点和各种方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;<span class="comment">//根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.getNo() == no) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.midOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Node left;<span class="comment">//默认null</span></span><br><span class="line">    <span class="keyword">private</span> Node right;<span class="comment">//默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点  叶子结点，删该叶子  非叶子结点，删子树</span></span><br><span class="line">    <span class="comment">//因为二叉树单向，所以判断当前结点子结点是否要删除，而不能判断这个结点是否要删</span></span><br><span class="line">    <span class="comment">//先判断root空 或者 就是要删除root</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//输出父结点</span></span><br><span class="line">        <span class="comment">//向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        <span class="comment">//向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.left.midOrder();</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//输出父结点</span></span><br><span class="line">        <span class="comment">//向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.right.midOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        <span class="comment">//向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);<span class="comment">//输出父结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>动态代理</title>
    <url>/2021/04/07/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(person);</span><br><span class="line">        proxyInstance.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">        handler.bind(obj);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object returnValue = method.invoke(obj,args);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i love ziwei&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>截图</title>
    <url>/2021/03/02/%E6%88%AA%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="qq截图"><a href="#qq截图" class="headerlink" title="qq截图"></a>qq截图</h3><p>平时加长截图效果不错</p>
<h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p>F12    然后ctrl+shift+p   然后full    效果一般 </p>
<h3 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h3><p>网页捕获    效果还好</p>
]]></content>
  </entry>
  <entry>
    <title>开始画画的起因</title>
    <url>/2021/04/05/%E5%BC%80%E5%A7%8B%E7%94%BB%E7%94%BB%E7%9A%84%E8%B5%B7%E5%9B%A0/</url>
    <content><![CDATA[<h1 id="开始画画起因"><a href="#开始画画起因" class="headerlink" title="开始画画起因"></a>开始画画起因</h1><p>​        其实在小学的时候，我是对画画有兴趣的，还记得我一丝不苟的模仿着语文书上的小梅花鹿，一笔笔勾描出它的模样，心中是充满成就感的，画完之后再送给其他人，获得同学的夸赞。其实画的一般，不过在那时喜悦也让我画了好几只梅花鹿，想来我还是热爱画画的。</p>
<p>​        很正常，我的生活逐渐被学业填充，一直没什么画画的时间和动力。今天，我想培养自己的一些兴趣爱好，也让自己变得优秀一点点，思来想去，想到了朋友在之前用ipad画的简笔画，很是可爱，我也很是羡慕，那么就试试吧。</p>
<p>​        我在B站认认真真学习了procreate的基本功能，软件的功能确实很强大，我像小孩子一样忘记了时间，笨拙的画着画，还是蛮开心的。</p>
<p>​        那么开始画画喽~~</p>
]]></content>
      <categories>
        <category>Paint</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo+gitee博客</title>
    <url>/2020/12/04/%E6%90%AD%E5%BB%BAhexo+gitee%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<a id="more"></a>



<p><a href="https://telcruel.gitee.io/2020/02/13/Hexo/">https://telcruel.gitee.io/2020/02/13/Hexo/</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="五、排序"><a href="#五、排序" class="headerlink" title="五、排序"></a>五、排序</h1><h2 id="1、常见的排序算法"><a href="#1、常见的排序算法" class="headerlink" title="1、常见的排序算法"></a>1、常见的排序算法</h2><p><img src="/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.1.png"></p>
<h2 id="2、算法的时间复杂度"><a href="#2、算法的时间复杂度" class="headerlink" title="2、算法的时间复杂度"></a>2、算法的时间复杂度</h2><h3 id="时间频度和时间复杂度"><a href="#时间频度和时间复杂度" class="headerlink" title="时间频度和时间复杂度"></a>时间频度和时间复杂度</h3><p><strong>时间频度T(n)</strong></p>
<p>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中<strong>语句的执行次数成正比例</strong>，哪个算法中语句执行次数多，它花费时间就多。<strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为T(n)。</p>
<p><strong>时间复杂度O(n)</strong></p>
<p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p>
<p>在T(n)=4n²-2n+2中，就有f(n)=n²，使得T（n)/f(n)的极限值为4，那么O(f(n))，也就是时间复杂度为O(n²)</p>
<ul>
<li>对于不是只有常数的时间复杂度<strong>忽略时间频度的系数、低次项常数</strong></li>
<li>对于只有常数的时间复杂度，将常数看为1</li>
</ul>
<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><h4 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶 O(1)"></a>常数阶 O(1)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i++;Copy</span><br></pre></td></tr></table></figure>

<p>无论代码执行了多少行，只要没有循环等复杂的结构，时间复杂度都是O(1)</p>
<h4 id="对数阶O-log2n"><a href="#对数阶O-log2n" class="headerlink" title="对数阶O(log2n)"></a>对数阶O(log2n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;n) &#123;</span><br><span class="line">    i = i*<span class="number">2</span>;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>此处i并不是依次递增到n，而是每次都以倍数增长。假设循环了x次后i大于n。则2x = n，x=log2n</p>
<h4 id="线性阶O-n"><a href="#线性阶O-n" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">	i++;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>这其中，循环体中的代码会执行n+1次，时间复杂度为O(n)</p>
<h4 id="线性对数阶O-nlog2n"><a href="#线性对数阶O-nlog2n" class="headerlink" title="线性对数阶O(nlog2n)"></a>线性对数阶O(nlog2n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;n) &#123;</span><br><span class="line">		j = j*<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>此处外部为一个循环，循环了n次。内部也是一个循环，但内部f循环的时间复杂度是log2n</p>
<p>所以总体的时间复杂度为线性对数阶O(nlog2n)</p>
<h4 id="平方阶O-n2"><a href="#平方阶O-n2" class="headerlink" title="平方阶O(n2)"></a>平方阶O(n2)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">		<span class="comment">//循环体</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h4 id="立方阶O-n3"><a href="#立方阶O-n3" class="headerlink" title="立方阶O(n3)"></a>立方阶O(n3)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">			<span class="comment">//循环体</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<p>可以看出平方阶、立方阶的复杂度主要是否循环嵌套了几层来决定的，所以要找程序中最复杂的那段。</p>
<h2 id="3、排序算法的时间复杂度"><a href="#3、排序算法的时间复杂度" class="headerlink" title="3、排序算法的时间复杂度"></a>3、排序算法的时间复杂度</h2><p><img src="/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.2.png"></p>
<p><strong><em>插入  堆  归并  快速排序</em></strong></p>
<p>不稳：相等的两个数，排序之后，相对顺序可能会改变。</p>
<p>​        《忆排序》</p>
<p>选冒插    快归堆    希    桶计基</p>
<h2 id="4、对数器验证算法"><a href="#4、对数器验证算法" class="headerlink" title="4、对数器验证算法"></a>4、对数器验证算法</h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] genereateRandomArray() &#123;</span><br><span class="line">        Random ran = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">            i = ran.nextInt();</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = genereateRandomArray();</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, arr2, <span class="number">0</span>, arr.length);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        SelectionSort(arr2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> same = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != arr2[i])</span><br><span class="line">                same = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(same);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、选择排序"><a href="#5、选择排序" class="headerlink" title="5、选择排序"></a>5、选择排序</h2><p><strong>算法步骤</strong></p>
<ul>
<li>遍历整个数组，找到最小（大）的元素，放到数组的起始位置。</li>
<li>再遍历剩下的数组，找到剩下元素中的最小（大）元素，放到数组的第二个位置。</li>
<li>重复以上步骤，直到排序完成。</li>
<li>一共需要遍历数组元素个数-1次，当找到第二大（小）的元素时，可以停止。这时最后一个元素必是最大（小）元素。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">	<span class="comment">//从小到大选择排序，放到前面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从第0个元素开始比较，一共循环length-1次，最后一个无须进行排序</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="comment">//保存最小元素的下标</span></span><br><span class="line">			<span class="keyword">int</span> minPos = i;</span><br><span class="line">			<span class="comment">//将该元素与剩下的元素比较，找出最小元素的下标</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;arr.length; j++) &#123;</span><br><span class="line">				<span class="comment">//保存最小元素的下标</span></span><br><span class="line">				minPos = arr[j] &lt; arr[minPos] ? j : minPos;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//交换元素</span></span><br><span class="line">			<span class="comment">//如果不是arr[i]不是最小的元素，就交换</span></span><br><span class="line">			<span class="keyword">if</span>(minPos != i) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp;</span><br><span class="line">				temp = arr[i];</span><br><span class="line">				arr[i] = arr[minPos];</span><br><span class="line">				arr[minPos] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进：可以在一次找最大（小）的过程中同时找到最大最小，然后分别放到前面和后面。</p>
<h2 id="6、冒泡排序"><a href="#6、冒泡排序" class="headerlink" title="6、冒泡排序"></a>6、冒泡排序</h2><p><strong>算法步骤</strong></p>
<ul>
<li>比较<strong>相邻</strong>的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，<strong>最后的元素会是最大的数</strong>（**<em>向后冒泡**</em>）。</li>
<li>针对所有的元素重复以上的步骤，<strong>除了最后一个</strong>。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
<li>一共进行了<strong>数组元素个数-1</strong>次大循环，且每次大循环中需要比较的元素越来越少。</li>
<li>优化：如果在某次大循环，发现没有发生交换，则证明已经有序。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="comment">//从小到大</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">         <span class="comment">//定义一个标识，来记录这趟大循环是否发生了交换</span></span><br><span class="line">         <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">//只需要比较前length-i个数</span></span><br><span class="line">         <span class="comment">//每次排序会确定一个最大的元素</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;arr.length-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">               <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">               arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">               arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">               <span class="comment">//发生了交换，标识改为true</span></span><br><span class="line">               flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果这次循环没发生交换，证明两两都是符合的，直接停止循环</span></span><br><span class="line">         <span class="keyword">if</span>(flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7、插入排序"><a href="#7、插入排序" class="headerlink" title="7、插入排序"></a>7、插入排序</h2><p><strong>算法步骤</strong></p>
<ul>
<li>将待排序序列第一个元素看做一个<strong>有序序列</strong>，把第二个元素到最后一个元素当成是<strong>未排序序列</strong>。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</li>
<li>区别：  冒泡是把前面中最大或最小相邻比较放到后面。  插入是把下一个未排序的值相邻比较放到合适的位置。</li>
<li>最好情况：O（n）每次只相邻比一次，不用移动（n-1）*1</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从小到大 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>&#125;;</span><br><span class="line">      <span class="comment">//从数组的第二个元素开始选择位置插入</span></span><br><span class="line">      <span class="comment">//因为第一个元素已经放入了有序数组中</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">         <span class="comment">//向前移动的就是第i个，和前面比较</span></span><br><span class="line">         <span class="comment">//如果a[j] &lt; a[j-1]才继续移动，不然就跳出</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; a[j] &lt; a[j-<span class="number">1</span>] ; j--) &#123;</span><br><span class="line">             <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">             arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">             arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>简单排序算法：<ul>
<li>冒泡：基本不用，太慢</li>
<li>选择：基本不用，不稳</li>
<li>插入：最快，稳定，样本小且基本有序时效率高</li>
</ul>
</li>
</ul>
<h2 id="8、希尔排序"><a href="#8、希尔排序" class="headerlink" title="8、希尔排序"></a>8、希尔排序</h2><p><strong>回顾：插入排序存在的问题</strong></p>
<p>当最后一个元素为整个数组的最小元素时，需要将前面的有序数组中的每个元素都向后移一位，这样是非常花时间的。</p>
<p>所以有了希尔排序来帮我们将数组从无序变为整体有序再变为有序。</p>
<p><strong>算法步骤</strong></p>
<ul>
<li>选择一个增量序列t1（一般是数组长度/2），t2（一般是一个分组长度/2），……，tk，<strong>其中 ti &gt; tj</strong>, tk = 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<p><strong>示意图</strong></p>
<p><img src="/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.3.png"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span> temp;</span><br><span class="line">      <span class="comment">//将数组分为gap组,每个组内部进行插入排序</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> gap = arr.length/<span class="number">2</span>; gap&gt;<span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="comment">//i用来指向未排序数组的首个元素，前面gap个当作已排序</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">             	<span class="comment">//相当i对应的数与同一组前面的进行插入排序</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; gap - <span class="number">1</span> &amp;&amp; arr[j] &lt; arr[j - gap]; j -= gap) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                    arr[j - gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Knuth序列 h = 1		 h = 3 * h + 1		</span></span><br><span class="line">		<span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt;= arr.length / <span class="number">3</span>) &#123;</span><br><span class="line">            h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = h; gap &gt; <span class="number">0</span>; gap = (gap - <span class="number">1</span>) / <span class="number">3</span>) &#123;</span><br><span class="line">           <span class="comment">//****************</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2 id="9、归并排序"><a href="#9、归并排序" class="headerlink" title="9、归并排序"></a>9、归并排序</h2><p><strong>算法步骤</strong></p>
<p>归并排序用到了<strong>分而治之</strong>的思想，其难点是<strong>治</strong></p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复上一步 直到<strong>某一指针达到序列尾</strong></li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<p><img src="/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.4.png"></p>
<p><img src="/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.5.png"></p>
<p><img src="/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.6.png"></p>
<p><img src="/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.7.png"></p>
<p><strong>此时第二个序列的指针已经到达末尾，则将第一个序列中剩下的元素全部放入和合并序列末尾</strong></p>
<p><img src="/2021/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.8.png"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将分解的序列进行合并，合并的同时完成排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr 待合并的数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left 数组左边界</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right 数组右边界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当left == right 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        mergeSort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, right);</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//两个序列的分界点</span></span><br><span class="line">      <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">      <span class="comment">//temp数组中插入的位置</span></span><br><span class="line">      <span class="keyword">int</span> tempLeft = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> arrLeft = left;</span><br><span class="line">      <span class="comment">//第二个序列的首元素下标</span></span><br><span class="line">      <span class="keyword">int</span> arrRight = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(arrLeft&lt;=mid &amp;&amp; arrRight&lt;=right) &#123;</span><br><span class="line">         <span class="comment">//如果第一个序列的元素小于第二序列的元素，就将其放入temp中</span></span><br><span class="line">         <span class="keyword">if</span>(arr[arrLeft] &lt;= arr[arrRight]) &#123;</span><br><span class="line">            temp[tempLeft] = arr[arrLeft];</span><br><span class="line">            arrLeft++;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp[tempLeft] = arr[arrRight];</span><br><span class="line">            arrRight++;</span><br><span class="line">         &#125;</span><br><span class="line">         tempLeft++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//将不为空的序列中的元素依次放入temp中</span></span><br><span class="line">      <span class="keyword">while</span> (arrLeft &lt;= mid) &#123;</span><br><span class="line">         temp[tempLeft] = arr[arrLeft];</span><br><span class="line">         tempLeft++;</span><br><span class="line">         arrLeft++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (arrRight &lt;= right) &#123;</span><br><span class="line">         temp[tempLeft] = arr[arrRight];</span><br><span class="line">         tempLeft++;</span><br><span class="line">         arrRight++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将临时数组中的元素放回数组arr中</span></span><br><span class="line">      tempLeft = <span class="number">0</span>;</span><br><span class="line">      arrLeft = left;</span><br><span class="line">      <span class="keyword">while</span> (arrLeft &lt;= right) &#123;</span><br><span class="line">         arr[arrLeft] = temp[tempLeft];</span><br><span class="line">         arrLeft++;</span><br><span class="line">         tempLeft++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>语言中对象的排序需要稳定，一般用的是归并排序，java中用的是Timsort，改进的归并排序</li>
</ul>
<h2 id="10、快速排序"><a href="#10、快速排序" class="headerlink" title="10、快速排序"></a>10、快速排序</h2><p><strong>算法步骤</strong></p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">       quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> leftBound, <span class="keyword">int</span> rightBound)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (leftBound &gt;= rightBound) <span class="keyword">return</span>;</span><br><span class="line">       <span class="comment">//得到轴位置</span></span><br><span class="line">       <span class="keyword">int</span> mid = partition(arr, leftBound, rightBound);</span><br><span class="line"></span><br><span class="line">       quickSort(arr, leftBound, mid - <span class="number">1</span>);</span><br><span class="line">       quickSort(arr, mid + <span class="number">1</span>, rightBound);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> leftBound, <span class="keyword">int</span> rightBound)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//最左边的数作为轴</span></span><br><span class="line">       <span class="keyword">int</span> pivot = arr[leftBound];</span><br><span class="line">       <span class="keyword">int</span> left = leftBound;</span><br><span class="line">       <span class="keyword">int</span> right = rightBound;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//填坑法</span></span><br><span class="line">       <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">           <span class="comment">//顺序很重要，要先从右边开始</span></span><br><span class="line">           <span class="comment">//右边找到第一个小于pivot的值,为了稳定，右边等于pivot，不移动，继续向左找</span></span><br><span class="line">           <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) right--;</span><br><span class="line">           <span class="comment">//后面填到前面的坑</span></span><br><span class="line">           <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">               arr[left] = arr[right];</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//左边找到第一个大于pivot的值，为了稳定，左边等于pivot，要把这个值移到轴的后面，所以不向后找了</span></span><br><span class="line">           <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt; pivot) left++;</span><br><span class="line">           <span class="comment">//前面填到后面的坑</span></span><br><span class="line">           <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">               arr[right] = arr[left];</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//基数放到最后left=right的那个坑</span></span><br><span class="line">       arr[left] = pivot;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Arrays.sort()中如果对基本数据类型排序，用的是双轴快排，两个轴分成三个区域</li>
</ul>
<h2 id="11、计数排序"><a href="#11、计数排序" class="headerlink" title="11、计数排序"></a>11、计数排序</h2><ul>
<li><p>适用于量大范围小的排序</p>
</li>
<li><p>如：高考成绩 学生只可能 0-750</p>
</li>
<li><p>先统计每个数的个数，对应数组值+1</p>
</li>
<li><p>根据数组的值来从小到大列出多少个值</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表顺序存储结构</title>
    <url>/2021/03/05/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gewen</span></span><br><span class="line"><span class="comment"> * %create 2021-03-06-11:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xianxingbiaoshunxu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List1 l = <span class="keyword">new</span> List1(<span class="number">3</span>);</span><br><span class="line">        l.insert(<span class="number">0</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        l.insert(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        l.insert(<span class="number">2</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        l.insert(<span class="number">3</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">        l.insert(<span class="number">4</span>, <span class="string">&quot;e&quot;</span>);</span><br><span class="line">        System.out.println(l.indexof(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(l.remove(<span class="number">1</span>));</span><br><span class="line">        System.out.println(l.remove(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        System.out.println(l.replace(<span class="number">0</span>, <span class="string">&quot;ddd&quot;</span>));</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        System.out.println(l.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List1</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> Object[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= array.length) &#123;</span><br><span class="line">            expand();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = size; j &gt; i; j--) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        array[i] = o;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在指定元素前插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = indexof(o);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        insert(index,o);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object[] newArray = <span class="keyword">new</span> Object[array.length * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            newArray[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        array = newArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = indexof(o);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> remove(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object old = array[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = index; j &lt; size - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        array[size - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到数据的索引值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o == array[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(array[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">replace</span><span class="params">(<span class="keyword">int</span> i, Object o1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object o2 = array[i];</span><br><span class="line">        array[i] = o1;</span><br><span class="line">        <span class="keyword">return</span> o2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回指定位置元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;List1&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;array=&quot;</span> + Arrays.toString(array) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>线性表链式存储结构</title>
    <url>/2021/03/09/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node();<span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node front = head;<span class="comment">//指向头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node rear = head;<span class="comment">//指向尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;<span class="comment">//保存元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的</span></span><br><span class="line"><span class="comment">     后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，</span></span><br><span class="line"><span class="comment">     进行删除操作的端称为队头。队列中没有元素时，称为空队列。队列又称为先进先出（FIFO—first in first out）线性表*/</span></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert1</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(o, <span class="keyword">null</span>);</span><br><span class="line">        newNode.next = front.next;</span><br><span class="line">        front.next = newNode;</span><br><span class="line">        rear = rear.next;<span class="comment">//新的节点成为尾部结点</span></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾插法添加结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert2</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(o, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        rear.next = newNode;</span><br><span class="line">        rear = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果给了链表中的结点p来插入，在这个结点p后插easy</span></span><br><span class="line"><span class="comment">    在这个结点p前插，因为没有前面的指针，所以可以先在p后面插一个p，然后把原来的p改为新的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//在i处插入结点 head相当于0位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt; size + <span class="number">1</span>) &#123;<span class="comment">//不能在0和以前 可以在size后添加一个</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;超出链表范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;<span class="comment">//让front指向i位置前面一个结点</span></span><br><span class="line">            front = front.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(o,<span class="keyword">null</span>);</span><br><span class="line">        newNode.next = front.next;</span><br><span class="line">        front.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i, Object o)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果按照指定结点p删除 先p.data = p.next.data; 然后p.next = p.next.next;</span></span><br><span class="line"><span class="comment">    相当于后面的数据占据p的 新的p结点指向p.next.next</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//出队 队头元素 返回出队值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = front.next;</span><br><span class="line">        Object o = temp.data;</span><br><span class="line">        front.next = temp.next;</span><br><span class="line">        <span class="keyword">if</span> (rear == temp) &#123;</span><br><span class="line">            rear = front;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建整表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//列出所有结点数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (front.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            front = front.next;</span><br><span class="line">            System.out.println(front);</span><br><span class="line">        &#125;</span><br><span class="line">        front = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回元素o在线性表中第一次出现的索引值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (front.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            front = front.next;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> &amp;&amp; front.data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o.equals(front.data)) &#123;<span class="comment">//不能用==</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回第i结点的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Privacy</title>
    <url>/2021/04/01/Emotion/2%E5%86%8D%E9%81%87/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c1a74fbc27a75522b8f13e53034685e6ea6100c844e423a418d94deb31c09c8b">99aecf667802343ef865f4967ee97da78d9f420655c36fac6674584d8c568c3fb50e8af73b86db48360c09e0155b065f0bc41b2c4cad6d7a4f55bb7c9105d672043c56fcaeb57e704ce43aa33b084d8367eef4d89968221644db9e739a90bf0d7c8e6f2cc85e93f2c40a1f3ca8f87baa912cf485ce26325e7001771b963385205d53e28582af7c3fcdbe1381fe37a0005953f4fa02b57d8ab71f954dd6c26fd69c818db8a61470846152745b591337710af2e15dc7334ec7b5153db02e5c3496bcfe73eee8a6a3996e74b6f715ec5f6d5679ad8940bd781d39eaf6f0546b40fe251829ce84ddd92ab9edf140a4d13bad5f13a720e5fef56f2df4099115b354b8042ccd196a20734d342ac38a58cd0fa7fdedbf33598aae55c53c3d0a27ac1f62f86d4cabe44c1af82c93da9c1b9ebcba3b2384375f4ed3409e31390d57e13bb27069131a55daf82c5556f012494ef12ac0afe66e2b5e5ec4a307a7e627e64b290881becf37d72690f6976d7a951768a46ce6919f015ac774e81783534bfe9a1fbc4cc2d19777af22ce56be28508b787a458afb00d3fbbeec1d3f4289e8aac7d685d635f0e8310cd23efe33057c1946f5f8e8f28bfd440c5d7e7409154033db5f63c9de43fe63cfea9d9b485c9d50a48cb2a358c5b84a0a489d03b28e5b4a2dad54c052f606043a8e99cc7d75adc01746a7a0305324ba99862c393a8f1f53f900c9ef5afd68e106128d1058cf195ef347f456da31105a0421216b11b7e336df545408020ea98bacd45b8445fde372dfb67251ecc252a4a06c928930be792ced64acf0948c469ac553d5a6949c7225a1c9f163172d93ee96e6c44875842189275474d8687d64840b490804468d6838b8b9700cb3c85bd4466663ba24aeab192be0793f8254b7cab07aa2408791acec6fd34d98878dac5dc558e4b13c61cee05acc25260a15d8dd06aa4d155e293a2dfe0e8efcf8410d46afe5e5260a90ccd20dffe4c4095a99fe7e7d477f7ffb7903dbf9410ba6d91b6f4c8424149e89b71d1316491c113375b6365783d7247090d031cd2bef7ce077caddfb5f24b9d0b414d1e0ff5bae35811a61b4ef72680b80f15f369dc56f3bbd437957ede62f13afa70017c10627c07d897609e0d6e69d3df9b6244bf43274f921bbb16de96ec93e812f476f7354caac5e872fae52c9406c5232db1199865989fea645c711802c601379b94ca7e8529ff9dad44c70bc79dff3de6923d74403d63daf1c748aacd54bf97d8938e43462e624b641538ac14471853f1042dc852a9b325813d0af5e3bcb9908d5cb64a3cd6b6bc507eef3619669e9f33f60ba692b0156ffd6add28bbb8ca4b0c376741ce389160652380bf3d387a2e97793055fc4c297ab1cb001e25e149bd29f3eabef8e8abf3a0eda573026a28cd320ac224934950bd34725476b0a45c6c0d522cb8fdc6cf1f654c88537a311dc8f521765df4feca92fb37edc8443150cc758e782d3e16c3098cdc164248232ea9161ad61545a6a16454bd3dd5b4f4b35cef3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Emotion</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy</title>
    <url>/2021/04/02/Emotion/3%E5%88%9D%E6%AC%A1%E8%81%8A%E5%A4%A9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c553d4e4c8fe95ddcf890ed73d93725f5952bc5ccd60a363da53fbf9cceeecb0">99aecf667802343ef865f4967ee97da78d9f420655c36fac6674584d8c568c3f18267addf9360df08e402bd766ddc454e0530dd4d24efb3100282fa40e6c08cb6ea1558b15d0783e955c9e1e2daad58985ce81f8ea6f7b216cdd39fa4f448ef8e9ff3991c33003a38af0ccc9a6531bab8c52285b8d4e19941377e483dda961a3a6e55e8cc3b3f9e87ed7fc36b4448a3d7757aaa6a0cfe6805032687ac72b6f116cfc5f77f4f9a017b0c92352d82164bff015d683eccfb7d508e221e9058b0983769ad860f4363a06f47a989e3623114b0c536cb45da9edc4ff864d18189594c6c9b5d7869742141df79859d3221a0213654065dd8fcc7cdeabe1a276dbf36e7a1f2eda04f1a4d12a2edca9b487d25614e1fa65bb611d32244bfe14aa16269bd95b9766a3835e2e8262ee72a7d24d20cf28f3d23e367c4f86c9d5597595b59abc4199e2d5b2467b8ad4996baea1676d699eeeb2af7ebd40bf7a321e2e3c1a8fdd7adc7f3003657cebd5d702d82ca1171f549f8109a6aa6ed047cb292bae4b094ab01a4dcf4e2bda0dfec4aad8dd3de097a84589d366afb66ba807b0ed9f45ce2e0deffa9716895b5a5797f3975e688114b3f79bd70d96018e3f9a9611aab1c68e2df6f05c0ab84cf809af2b3bd2ca469f25781dca78157b9c21e93e6b0858018d781f656273d4da7a6c7c8dd1053b8820d11afded9b5ca1140d40a4409929e2d4ce6bb9123b6143f4b773d07c5af2c8beccbeb53f1b10b0cc95d9758442fe4b6dc68f5ac7f594c5925e76e2f65a07d8b3806ea8a57a2f9d0ed3b86f48dc1cc612673ebe51a1a769907d4d5da60c9c4161e331c77445c47e6c5df94f18f1f42cabfa2a5ffc629f47b6265a1e37a55847476d46f548028ed1073c82e905e2588e6d511efe9097e34d777cee2374f7b55a875dee74af5364988acec7383d5fb7db29443ab641721b13e41823f440581c2e1f3ac8bc3004622b224038bc688687b4283442568396bb45a15fcf63f290e0ec1b8da71138ec9f19242fb23faddbeb18be378fe6fe1d8dbfafaf8a510c5c9343978ef53af7d4d7d4f54b5f65bb72c4a6702b96b550d2cff97eb9176af36cb0be0fd2e43f43af4b87fc25a8475622d175dabc09cca0129ac6f1af492b05dfd5fcae256e2e0a8b65cc94a8d03c23dcfa64cfb256ff4b15bb8f13dd64d5d268070e5b0c18f498ac1ce25c1e2258d2250fad847d8b088d406ad7a8f075abcd1c50df0195784caba152e55e14ea47dfd26539f5c5d262e2d7a1dab852d0a6c3a4c1d61592e81279bb8adcef0559abc09e31914c9c4b857a311d11cce6d4dfdd7a7f5992f55f34efd6a902097ec81f0da3395c6cb80cfc79a601cf935c7a866bde9882b9a0d9dfa471bfc2870a8faedcf20965d19193fb6a982e6e70aea0d4f4511bdee07d43fb7c0d0456653090995b131a776827a5aabea035fdef94df3d72b20275e7a445e914d75d4971cdf18bd923d913d2aa3e0c49c067a886040bbfc6f0bfe3de1d21087f6d69330d37b668902646e25bc3da1ad878c745a78ca92a5c2a25a20e63b7acc7d608294f87b1757266c7b1d6100d3255569c875e5c3c82509f3613c93641eaef8f79800bd49b5c75d6a6628daecbc35271b6ebffac72974b841273098ba2c04b88515a2dceaca3c71effb21349e85479887682fb4e7ba8121d50e48272274be7724be82a708ad04faab369ec0dc2425efe451b0922104a8159680c0bda1916b8fbf4827bcd93a36a920630047b190549a1529521dadb17d51c15f6ecd6586574dce6e435036eb28b6d0a63d5c53f41e187095f8e0f7d71302d3ac5c197423f9009b8a2503af5048ced6b4631bfcc58d968f579906e33e14a0f357b45b6c4670b37ecadf56fade4d3f7b4f224345170b089d5a8497fe3859ff67c2acd98196f6950ff65b626f0c0d5a9e25d34de1319b6bed31d4f7b21b1b2412ebf79df70287b077fe129874f0ec48c8b0586342ded44aa8f5d59100c5897129a2c84f0aa78f74a0190c10b3a08bc7cb9d4a124c9e2247931273b972afb7fb654d3024f7cb2b2718d74fd92ac999185da4db2f3fc9d35763e8c8818a1a1a4d5607c65f4b8d514bc5184cf63c8dcb39e88c920de38faa1d446f8c6e0fdb49d1aac2deaa06002488b01cf6913efe20879d1f815b370ac413b2a6f9aa2aa94562ed1d39853287575db5869665a8f9d7ba5169697557fe64379910167f8642aa7a9bbef9681a729750ffa54a70791321795b3e76d4c17b33f659df414f2b378a5da1eb5736c2fc57367e870de0da03ac8a9249688f86e111222fa315d8bae3ae070839f5c21b321c4aea33cc1308bfc9b0f2435dc51a153839b2a89c03cc07f757875fac404b10656ba4b077407b73d64ec83d074ef2f83fbce91036be9b64c290568b65e8328f84c745e356540f1e76242f1d468ecd4273cb88c5520e15133bef456132642c26dc105265b9c16e2daaa907c5f2ec35564f3f9b1dda0cc785ff6bab4464a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Emotion</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy</title>
    <url>/2021/03/30/Emotion/1%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9699822199c5792897115d7d7bbfae6c5b51d1d197635eee711ccfce8cf80980">99aecf667802343ef865f4967ee97da78d9f420655c36fac6674584d8c568c3f55dbdeac9d3e3f96cd27d33953d9fd619bffb4b8f1c4c4b1622039e7667cec4aa8ef3db1dbbf575fbc2c688b1f19d4548472b452336d2ae3d41bcd7e71148484aeae3ca3e8bc6b80c86cd4d5e49a749bfb6ee3d109be657cfee6bdcce875f1d9fea1b552dc3c325a14cb5af99f6a784216010d17449a9715b484a83478434cb3f0aecd25c995e7dbcb89a27c1602d6ab5f4f54a03e449f44f6f417b9fb8dc20a58ce8edfc3e2663a91939620052e232f06940d92105084fc5b95c062a1c33f31b7caf13e59b33ee0965ff3046e900750ae4ad8c6c0a86f6efe97d6095504b11a86d8e95cb65ba7e4a4399ac6d39714cb1cef7af7bdcaa6e0fa2d1ff07e3e7b3629d7afca18763d03001eceaec73831607127637c409b6b0411fc1f2de7f9bc2d5db5b32eed67e0fa225dc9ab8d88fc18a3c167119cb5076f0eab421472662561a0ac23b4ec26287a2789000f965385ef122cc6924b8f0041ea6f00bbdb3315cebb2df057f4daefcfe0be0521a7eb08c566aae90b63e162ec8d630d402086acaaa6ef2c6599eb4dcadf9f99e227d0906031bd8a883441312038b27ac5c32221d14876a8a8f32adac9f4212632dad3f1fed40449af09b0b62a902952fe0438a2adf41170fd7e468ef0bc5d7efb0de22b377128c220219ff026613c4aeccd3627c2fb060a17806d91d0f5919adb96e9b74e9a698f5380e6acb3bb5245fc5ad80593b47e4cf6d1e42162b5304ab71478725474ccaa7710b771cc081baf7e4889abbbb26fdf6359cda23e24516e9e8ad8a973ab360a88c74aa665bc5a86214d7f51d730aa4fc91e29265de1fb36c14974be48ac827ef9bb2a760361e13966aebe2081af81a05623a90c56fc19aad128c2997e26007e744d975d518850e2c3b884d980d2b49d164d214ce243aa06dc1a2bee8c79e6246a977fb148e4a889e40c7aca8bb5f6a3a79902f967bb08c8aefbc35ffc198842f7000db23367831b69b781e20e928f2a5fa97804954325656b6499bc13d1ad94969e59cd9548ee4f154edf3ccdb613ac952b69b21340b12b83e637d0dff77dfd12c1febe0d1fd9480a16f795d8c27240ee362f2a2dd895f6939e21e09c6703e458646cb340e1cbb10ee0e6cfa1eed587d685eea755357c762d236f4156f245be06bab80a7bdf44ce0848eb957da6eac5f1851559450a067dc2914c61315d9bbf4107549ef436b5f51e392ed73291a9e3394c41695a591d6dcaf5099a83ae1bd8b9aafed9b59e1b3252549eb3f9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Emotion</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy</title>
    <url>/2021/04/07/Emotion/5%E7%BA%A6%E6%89%93%E7%BE%BD%E6%AF%9B%E7%90%83/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="eea17aff334afa67289b804c8d19cf12af34de27c97ebf0832b9a909527e9ef2">99aecf667802343ef865f4967ee97da78d9f420655c36fac6674584d8c568c3fa0f53554bfd3239bf2308e0c4d49251a0ba5159cc55d522fca3d2d4f2902ac8b444417b7bc9ec385c26dd1446e3bd3a9ff01443d774f617f6cd2ef097befe7896ccee0aeb02bada1125e43eda1d93204c6c88f28dc8a94ed3c50d289f5970149ab59e03e424105c8d95a3938c0bfdbb46af803ee08963e84bfd300813c1680c474fe1d2793df5ff25f344d1f12f166c2d77761ac66a8a650e71ffd36b4a939067513e6931a6c969bba4f5fa76385444dc2e7aaeed7622ca6b329ab43fe69e4b83aa7757f858987d4f5077b197c5d56b4557b7e280ac0aa647474bd51c9a83c13450b959f974330f3cb0e8aaa07c25666409afa2b439a1670411982c02a61053164051a96fcc162bb3a54a0fb127ec8023a3381ef5350e6f34599b64ca7742f482ceba6548b94e4ef60087e9ecbed508b66f9fecf557c4136f4ae41c1d289e975bf9704fbd7057f99e1f5a2144a437c77136c63f65475b7b8082d6a9be03e665a4f56187b44e1d184e3cf6752ba8ccb0efa6390fa09309a574473d1655db4769f3f647122276427b5f567345dbb991154b6e16a10c40112f635daeac3cd3e746ce448aef72da707ebac83943aedd036f46184ea4358fca17cd86a6ffc41726cc4075bca04332c3b9a2f562f0e17db12c0ee493051b5b468df8b4763848599cbe5170108f0b4a08b8c9448f762c92dfdaecac49a4bad1429ac9a3286e4cf557246bb3305bcda0df07f5ff281eb91eca7986050c07da47dd6a0abf753a70181232fd20e86c4e3dd5fffde8331d59c60f1cff9ffdcb961ccb7152d4dbddcc945b186941385004e5bf3d8630a49b3faaa767e465128f70c26f0ffa6c737dcc5d158b0b45c6b644e8806f5ba88d87e299d978c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Emotion</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy</title>
    <url>/2021/04/03/Emotion/4%E6%B8%85%E6%98%8E%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7fbeaec664c7e927fb92ea8573a2a1297e239a2a920fc13da52b603c29d51e17">99aecf667802343ef865f4967ee97da78d9f420655c36fac6674584d8c568c3fd4295b1dd01a6b9c1ae2bcbe9ed564c7da85aa5c4e5e109bac4d956081ac167c77ded9016cb0b586fb5ddce2372523d43d1faebfd49353e6cc1491574e51ebdb84cd77fe62d4c1e95bb449d46a59a5e19810313d0e24ca0a98bf3b3e7360f68d1f0322c9d4c88ae4c1340ba05d047206a0d908fcc1ee8746742f0c5e9376f5ab0ab129e89bea0e3a6e306820df035fdefe56160a5b579b8b0f74ed8c953ed8d013d501b3740eacd138bdaf1f77952a5193eedec4180e5b7e4b0be32d82787ceceb855500980f0378165050b4b764c3d22455463077788d2b9f469a8fc681b4b1be4d5c84062a8ee72fcdc744d865bafef32ab47901d16dec9e286c416dc0c1a7ed6c085d81de40c1259f9b9e3b662151e49ca5c4663ea1782dccffbe1fc6769fc6c72efc7a744b9a662a80e47b609371690742761e173e789c2376a746d63559ef760233e40cb3e9cb9fcc9ae36f4ed00f43281e5f4a29955a2bc381742f1676de68cb96b0a59b5ea0a2831f4b3249db8ba1d0a05bd0c0cb66992a53fa6bc7cc5e55e4df1943785fedca7ae6b6d03b5bbc071e33df99b32a0f5adf564d050efb8dd23e99e27e1ffc89ba9180da8211816529ba139c37c1b2e723ef1d2db61b25c48817c0f503b399064b6d076f98c99ba0ef94e3c1fd684ede3093de7dbb2e16bf3ba1301dc604e6c521ca0079adcb3cd9909f7d90aeb4d640758699b6594b3474db83db8b10d0080fdee58bae5ff4b1ad5d22fe91f190b368e46d041b027db135b22b661998a7197ebb3845862d31ac65d663ff07fce59a7d6d19e414f4fed4dbc661b957e25caf93f2afb9061406c059cebb2184a5c0e7e6f89aa2ae861b62385721d366f46bb39d556a2b6d13c0b709f1affa9f18ff8087f845707858e148cde4d98a3aaf3dea7899f9aa30fe4cfb69874c7a7f1f0e9e7018a27cd54de22c5ee2365d0bd3ae67bd78a46e8beab306a31ecffedb18a3f53c160e847ae7d9fbe0d9fe3cf8759158ef765156682ad84b233352005d9f60eac9363af7039fc20dbc009ff388e2020d2ba95296808099f5d832ea873a72a3727d9b08dc89b3d338c79c3839935fdcd5cc6ffd91e0f96a9ebb841621d695cb23e4a538c523612b14a537417006ed8c08ba7fbaef6b285b145a2ca70ae5ca7cb6a859b0dc3a00f1cf912364a40e1890f23ffa10537c19034f92ee7ff410e70ab6f673b8efc7dbbc62fa3655370bacc1acac2febb87c25e34dbfea4e6be15b3b7da47a6cba5a5ff7644050ed304d22fe96deb327b660c83ae2c5608b1a50759d2a2baad3c5e5d07ae49235fba3de8a9f0a3c51c5584a3f56fa4b44249632cdc679f6ea12569b218e72bb250a7f3c8465792b0bdedb20c567583863f7be5933c45e35cd3e023b1d578bc02e252597b73a22440fbd15c4c16ebbee9f7dab9656ba83f864ef9c57090159210b51df8c6a6aaf5650c9bff0b7a73dbc59515b87db902383d4278281c545cfd53da2e0cf9520c106e4da476907fafd8bac7923aed1ba280ebfefe93564a4d2624bc62ec43eba8006a4a79d762c5254bd6e6129c3fb335ec5fbfe271a37d694241f709abf3e7ce0bc5ca2e7363e6cf5a3dbd08333ffa4498db67cd12488d69cebde838ba58ed82b91dc1d52301903baec50a9f62340abbc1cae7be9f4039f23c1c545685028e7933d1f27ded8ae05ebe42c66fc8e190370b21b0a1062f933d15fb17d672b6a2698e5de98270c9c30c5081665feb7c7cbcab547a785f691daa110a321d76ebe84f9f9a4efe9d9571d25fb009386133487029fe18a0c43958ed2edb10ec3a28b70038aea0f3e1100b3b448f4a45d7bdcddb9967722ea9514c35be892bd1a72fa65dde73de7debdfc1b056ccad460dd272a6e47e18083fdf85930c39ca077dfc74edec327d955f99f8937414a5a74e2c5b89c25b54c2c047a21e424d7eba07bd70d5fc5f089c8eda0710000f9a803dc0ccbcae4b506b49b4ad3991a6d5bb51f4a92aeedcdd149e5d1c37d12b4ca2e742678240ba2e19a66888122a3537b3709ebf0ba14f5349bd4bed5e9ab655a7188cf9e235fbaa0496c17e607c2bc392ed96f5deda596ba514aef6fffbc359f198ed8990f01b0163a272de25e9e0f40d2c82595a71742c220cabb6160baf8c4935c4f5c33d3157c3654841282ebd0a53c9d9a859117b242feeee6d65d97959c866680e2a3ca37f74d0fb7a46b40a2385c6e7a8caf97d11a72446e63ecb0ba4e683ccd5f5aff462a13121df723176443e919a50873312d3f1bbb45d1c75b6495223bc960a540a361d3ffc82aa981383fc73af85a2ccc2e3208a76126bd</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Emotion</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy</title>
    <url>/2021/04/10/Emotion/6%E5%BF%83%E7%81%B0%E6%84%8F%E5%86%B7/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="58c433b0d62a42cc7456c59786620f3ade288036bd222015d80971a49abd793c">99aecf667802343ef865f4967ee97da78d9f420655c36fac6674584d8c568c3f9340d6a8b73e86d882b1285affe27e64610d1d16053bb8e9f3d26b8bb435e2be5ea79d4b5ad0aab97e0e287c83c14ac58daeed2d12d1ba0a270ca0b5b98e79c15165134f338cb78e3b2a8a43e2de76248d635cc8b70b644db82251c3318b17808b4312f09c3bef7e4a81cdd2b80f2a7063d7f17fe3f5c379d7dfd122161c96724c29f883a149c69d2695e26f072fe747761ab600cb03795f18aedf8c8b587b4853e804eafbd39f9846a534df12a4e590c487eee206a18953ea3f3e9f37d6682972ed7fe06b15e0d16a58be9cccc90d26e18e1a567e146b7ebc5077918d17f77acc85dc4d5ce0efdbe04beb9675eb1ba2cccc136e1dc2fb6de2cf881ed4d00db22656dfd0d7d4e51fb80e1756a4fdc61ce68ad515a403e3f37cf20e6647ed7631b82512f28e2cb0dc98abd654d8fadaf076065b088df2d4039082355627dcc9ba6270a5cddec4e4d2875684dc46e36bf5344f4f3c843d040958283c571507aaf699265326c681c359e2e895906c1f3df1d1393522a532a6195baa0936d39605e25d43898675b9d32a4877035a99ed019e7397d05402067eeeeadfb67f239849f43f6df6ef42ea494bfb8454d568f1c0d53f5944664c8d519c65c9016431ed1d92908f3dac5c47cf4853e1a1a18cafe767fa236f22a46e20898b30ace7c8ad94ccf6ba8241ec000a4b28ba5407da53915d1f497ef1b74c2e167f7e26fce83110482a5567cbb3bcc6d56280fda82535d958ff68756159e8b29e8526fe84710a8a0fb4cf742f0627bdd6f16f6dfbdc13e680daff901d4439a1f1ae0c1073f8a1b7bb32ca1849bbbe3699d37a89ff84dcd05cd944ed1a4c6fb39561bf1ba14782747dc1614c429bdd9b987aeed73e6717fdacd9b25068228e092e90a4f2055cbf5d411fe4067294a21ca6e8945a584043a9f2dfe2fc980e0b06c0fa81f99897cac32b334ac0c87da01f7bdc1b82daa8d1a59510ea56aa34d60023c3c211c40b39fd03</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Emotion</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy</title>
    <url>/2021/04/14/Emotion/8%E5%A5%BD%E6%83%A8%E5%95%8A/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="bd28d93266bd0ce0ac4f42f6d7213fcc99bfbe88e2472e84f3668795f422fa60">99aecf667802343ef865f4967ee97da78d9f420655c36fac6674584d8c568c3f08570f445c6a906217fbb5f7ab96372dcff102c12d8eeca119b1296fe04934897119441242629143e6451bd4eac2a410321e5d2c914448292e8beba5288931176007da554c2f2ed39769a3930c160fd57ea5f1b98e9941bd71cfab7029fe7790e09867473432ffcbecbb45bf36e782bb839a68dc6bc2cddf1f32c7c982b8e86de3f9cf9d0e3707d6ec39bc4f4d6016f0bbbee3a0d116b8e514ebec1c15f41c562e2564e604093c5aabebd02b4b415922c277770508ae7347a273ac55c78587b8ec3389988546b46cfaa79e09028693ac</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Emotion</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy</title>
    <url>/2021/04/10/Emotion/7%E6%84%9F%E8%A7%89/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="fde244a96394d020594a7c061a5114f5ff2b8e9ced346c0ba2f3117a36f80ba7">99aecf667802343ef865f4967ee97da78d9f420655c36fac6674584d8c568c3ffc8b5914dde74c84b65ac8c0f66a9a2aeebbf056a6472690bfa4d4b91c2fa2b380e58101de494e70a919766224a5694b20aec1fcf9bc2281cc2020976a4e1105a434d95f67320da1107061539eabd33438fde3ac555339b3de38bdb0c52b6bd95fcde3269789499f4c6055c9ea3fa11ab5ff8217cd89ed0d7e8991691f48220f5f78bd83fe19666dae521d93d9e562947f4ac981d1ef811d64ef03ce69a64d39b14b60716e00cfc8117503844ac12fcec514041351481601fa53a63137ee8b9dd7bb993578cb953335c27df51b928245328abc206ecea5952374515a67116873e406cd53399981dab967e901be7ea92caa3094a9fc9424edbe60d6959a2ffa23f217c4ffb0196a6998ccdd90a7154f84a368f0a861fb1361ff240eee731d4261f7dd76f8e9d3ed420613a479f4cf03d34b7f393e56c7ca0d735bf15926e875861eaf32f25226aa1f8db6b36360afeb980018a69d2baa0aa27dec82e08ec2f0da470f1a19215860a77205943a6b1c61f4</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Emotion</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy</title>
    <url>/2021/05/01/Emotion/9%E6%84%89%E6%82%A6%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3940af72c17a9fe6f660dbf054905d11bb07dcee5128184ae2f5c785fed1604a">99aecf667802343ef865f4967ee97da78d9f420655c36fac6674584d8c568c3f69da34af30e0b1aba6c0e5420e4892f116a95c7b8e67925c86e414ac9626496d32c2736bed6684c321c1939cd44854c743d9375b7f56dd26a0531e218595421871d17ca41128c939e39ffa97d8d6967df3d90949e55369980d013c81a0264a54d527699817eaf39b7152dc47f752c2dfeabe9effdb3253d6d567684428e878c6dc023d66ea5692171b81d29640b6ed434ddf96f0ba9ebd38a46c2fe2463ee53403df45b5018f1722cbf9cd23ee98230b1d4cab473f8c99f91697ec7766a8d5a427770dd0c086a5b6922a3aba143e3093ee37d4a4b962de18c3095792ede4925c0ac6ac51a69727c6c69508076495b5d3b96532f56f94c6a17b4c4795070e7273afb1a9fbbf72f2f51b00bf3af3e751efe48e4fb83847f5f53b6b14a6700ec7a9d35287465e49aedd6abde78f6b0396460e47f91a94c275285d97d292f2d78f03689e3aa23c52a9d97dbc1ab40d265914e4d69c9af746a0d83474e96000e49f84ad20f0edf351dbfa37b9101565a5fd87b046613617d909f7d8084ba038003338ee717d120e0d494840213a0ae2811b6ec0d1eae4f72f1cb5f16402fd79ec93ad1f6e2c5516d5272b0d226a3452fa51a365fde569de1f5b5f54a3d7c24fcc7b944f2b910880bd7b6652222a642ee665931bee885ad5c38244b45daccd0a28bb63194dd3620d2229f680807f064d8a0f4d465ca327a94325db46cc1f7bb3b5ab8622500f02f31fe5591013809bdf1d8305a41b9f5305692a0596c0c9ed532d5a9a7528c119b504a98a7a25411787ed3865a804fd917aa7633e8d293685c65d71cef50d1421bd5b3bc47d7361772da3a765a0f75a5a8ccf149c0c466a489123be2ca7fded6e8ab6950b0aff16a2b09515542b680a13f05c1cdf87e919f233496d7537059aa804933c6dec87fcec6ac5fe591d7cee95aa585057e06a950a605fd4a55675f80362473d573a5bd9523bec25eb025e4a7cfceabd3b5ccbcd0965f0e53d62cc7e0c17e224430e304607f49a55a0cfb449b8c1728bc5c66d5bdde60f2c2ef4a370fa3b91eb3936f9fd202ae8425f710f1ca5e3662d5b8d6a7974e2aca8d3934e4acc6af0e1c3c054d4a574bdcdec72988fd6c793ec173a1ba6c972852f9fb349c318359d759224a8a522688815a506b0d2e6d9394586e3a1a5ac06ea083a02732fae8363e55376081491f185f48396a575f5bf3c4e49d7a8c82469b67fd803d6369178b27ff60ba76894d5837e3f5d28a59b8f540a0e01932072126ea35d5f873e539911b4fe3ff937d87355a163ca03bb470e2118dacad33fac748d064b04472ce075656891c24e7530f6e0da1415bd02bf89179786674fb68e073048810a776636577c758a395fbe9f6d658ce7778359c2668f24b96c275ff4dacfb9d5c50e547e467f85bff9e0312f9f28c95e1ce27b67703349ecd6ada572676b26f7f977c1a7deee8522f773a9f5cd2cb3b3488ebb8ab1667a50e2c6624f268b292b9cc70938a13b7ed09a1175f3140edd0cef44f0ea8f15727671b836e0329fd96cceed292cb50ae82e3bd92603650005b33c5631955d50377d867afc74768e7e61a7832b7c318bde79baf39a4bce50bc28120263f9b1bec5f839bf770b288249a101257045a83296ad14085ab6ded3060dda13cd428e978bc4685ef95aeb1c9d913e2fd2492ea8ee439a5c1b0f337827bf085822db32fe36099abfe1ff91f351b05feea98048e695d98771ea928955a29dc459f82894a11bd932bae66a55b8aa8a9b2bd1f0b7f1f8a28757cc74ab6079e54ccb1e1bb2c8fd7486bdc406f0d7ee1fb9a1b8ade322f24d23e092245107bc911e136b2a790476f09d8f3965576a29759778cb5d783b82dc9b72a1fb6832e8fc6eeb7440b0d643f6a2caa120d4b37ca1e3ca738c6fb509cd45e1dc95043cb359</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Emotion</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql7-视图</title>
    <url>/2021/05/18/MySql7/</url>
    <content><![CDATA[<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul>
<li><p>视图：虚拟表,和普通表一样使用。mysql5.1版本出现的新特性，是通过表动态生成的数据。</p>
</li>
<li><p>视图的好处</p>
<ul>
<li><p>简化复杂的sql操作，不必知道它的查询细节</p>
</li>
<li><p>保护数据，提高安全性</p>
</li>
<li><p>多个地方用到同样的查询结果</p>
<a id="more"></a>
</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT stuname,majorname FROM stuinfo s</span><br><span class="line">INNER JOIN major m ON s.&#96;majorid&#96;&#x3D; m.&#96;id&#96;</span><br><span class="line">WHERE s.&#96;stuname&#96; LIKE &#39;张%&#39;;</span><br><span class="line"></span><br><span class="line">CREATE VIEW v1 AS</span><br><span class="line">SELECT stuname,majorname</span><br><span class="line">FROM stuinfo s</span><br><span class="line">INNER JOIN major m ON s.&#96;majorid&#96;&#x3D; m.&#96;id&#96;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM v1 WHERE stuname LIKE &#39;张%&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h4><ul>
<li><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view 视图名 as 查询语句;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line">#1.查询姓名中包含a字符的员工名、部门名和工种信息</span><br><span class="line">    #①创建</span><br><span class="line">    CREATE VIEW myv1 AS</span><br><span class="line">    SELECT last_name,department_name,job_title</span><br><span class="line">    FROM employees e</span><br><span class="line">    JOIN departments d ON e.department_id  &#x3D; d.department_id</span><br><span class="line">    JOIN jobs j ON j.job_id  &#x3D; e.job_id;</span><br><span class="line"></span><br><span class="line">    #②使用</span><br><span class="line">    SELECT * FROM myv1 WHERE last_name LIKE &#39;%a%&#39;;</span><br><span class="line"></span><br><span class="line">#2.查询各部门的平均工资级别</span><br><span class="line">    #①创建视图查看每个部门的平均工资</span><br><span class="line">    CREATE VIEW myv2 AS</span><br><span class="line">    SELECT AVG(salary) ag,department_id</span><br><span class="line">    FROM employees GROUP BY department_id;</span><br><span class="line"></span><br><span class="line">    #②使用</span><br><span class="line">    SELECT myv2.&#96;ag&#96;,g.grade_level FROM myv2</span><br><span class="line">    JOIN job_grades g</span><br><span class="line">    ON myv2.&#96;ag&#96; BETWEEN g.&#96;lowest_sal&#96; AND g.&#96;highest_sal&#96;;</span><br><span class="line"></span><br><span class="line">#3.查询平均工资最低的部门信息</span><br><span class="line">SELECT * FROM myv2 ORDER BY ag LIMIT 1;</span><br><span class="line"></span><br><span class="line">#4.查询平均工资最低的部门名和工资</span><br><span class="line">    CREATE VIEW myv3 AS</span><br><span class="line">    SELECT * FROM myv2 ORDER BY ag LIMIT 1;</span><br><span class="line"></span><br><span class="line">    SELECT d.*,m.ag FROM myv3 m</span><br><span class="line">    JOI departments d</span><br><span class="line">    ON m.&#96;department_id&#96;&#x3D;d.&#96;department_id&#96;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="视图的修改"><a href="#视图的修改" class="headerlink" title="视图的修改"></a>视图的修改</h4><ul>
<li><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">create or replace view 视图名 as 查询语句;</span><br><span class="line">方式二：</span><br><span class="line">alter view 视图名 as 查询语句;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h4><ul>
<li><p>用户可以一次删除一个或者多个视图，前提是必须有该视图的drop权限。</p>
</li>
<li><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop view 视图1，视图2,…;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="视图的查看"><a href="#视图的查看" class="headerlink" title="视图的查看"></a>视图的查看</h4><ul>
<li><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc 视图名;</span><br><span class="line">show create view 视图名;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h4><ul>
<li><p>插入：insert</p>
<p>修改：update</p>
<p>删除：delete</p>
<p>查看：select</p>
</li>
</ul>
<ul>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.插入</span><br><span class="line"></span><br><span class="line">INSERT INTO myv1 VALUES(&#39;张飞&#39;,&#39;zf@qq.com&#39;);</span><br><span class="line"></span><br><span class="line">#2.修改</span><br><span class="line">UPDATE myv1 SET last_name &#x3D; &#39;张无忌&#39; WHERE last_name&#x3D;&#39;张飞&#39;;</span><br><span class="line"></span><br><span class="line">#3.删除</span><br><span class="line">DELETE FROM myv1 WHERE last_name &#x3D; &#39;张无忌&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<p>​        视图一般用于查询的，而不是更新的，所以具备以下特点的视图都不允许更新<br>包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all<br>常量视图<br>Select中包含子查询<br>join<br>from一个不能更新的视图<br>where子句的子查询引用了from子句中的表</p>
</li>
<li><p>视图和表区别</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">		关键字		    是否占用物理空间			  使用</span><br><span class="line">视图		<span class="keyword">view</span>	   占用较小，只保存<span class="keyword">sql</span>逻辑	  一般用于查询</span><br><span class="line">表	    <span class="keyword">table</span>		 保存实际的数据			  增删改查</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>系统变量：</p>
<ul>
<li>全局变量</li>
<li>会话变量</li>
</ul>
</li>
<li><p>自定义变量：</p>
<ul>
<li>用户变量</li>
<li>局部变量</li>
</ul>
</li>
</ul>
<h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><ul>
<li><p>变量由系统定义，不是用户定义，属于服务器层面</p>
</li>
<li><p>注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p>查看所有系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global|【session】variables;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看满足条件的部分系统变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global|【session】 variables like &#39;%char%&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看指定的系统变量的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@global|【session】系统变量名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为某个系统变量赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">set global|【session】系统变量名&#x3D;值;</span><br><span class="line">方式二：</span><br><span class="line">set @@global|【session】系统变量名&#x3D;值;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><ul>
<li><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line">#②查看满足条件的部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;</span><br><span class="line">#③查看指定的系统变量的值</span><br><span class="line">SELECT @@global.autocommit;</span><br><span class="line">#④为某个系统变量赋值</span><br><span class="line">SET @@global.autocommit&#x3D;0;</span><br><span class="line">SET GLOBAL autocommit&#x3D;0;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h5><ul>
<li><p>作用域：针对于当前会话（连接）有效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">#②查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;</span><br><span class="line">#③查看指定的会话变量的值</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line">#④为某个会话变量赋值</span><br><span class="line">SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;</span><br><span class="line">SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><ul>
<li><p>变量由用户自定义，而不是系统提供的 </p>
</li>
<li><p>使用步骤： 1、声明</p>
<p>​                    2、赋值 </p>
<p>​                    3、使用（查看、比较、运算等）</p>
</li>
</ul>
<h5 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h5><ul>
<li><p>作用域：针对于当前会话（连接）有效，作用域同于会话变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①声明并初始化</span><br><span class="line">SET @变量名&#x3D;值;**</span><br><span class="line">SET @变量名:&#x3D;值;</span><br><span class="line">SELECT @变量名:&#x3D;值;</span><br><span class="line"></span><br><span class="line">#②赋值（更新变量的值）</span><br><span class="line">#方式一：</span><br><span class="line">	SET @变量名&#x3D;值;**</span><br><span class="line">	SET @变量名:&#x3D;值;</span><br><span class="line">	SELECT @变量名:&#x3D;值;</span><br><span class="line">#方式二：</span><br><span class="line">	SELECT 字段 INTO @变量名**</span><br><span class="line">	FROM 表;</span><br><span class="line">#③使用（查看变量的值）</span><br><span class="line">SELECT @变量名;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><ul>
<li><p>作用域：仅仅在定义它的begin end块中有效 应用在 begin end中的第一句话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#①声明</span><br><span class="line">DECLARE 变量名 类型;</span><br><span class="line">DECLARE 变量名 类型 【DEFAULT 值】;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②赋值（更新变量的值）</span><br><span class="line"></span><br><span class="line">#方式一：</span><br><span class="line">	SET 局部变量名&#x3D;值;</span><br><span class="line">	SET 局部变量名:&#x3D;值;</span><br><span class="line">	SELECT 局部变量名:&#x3D;值;</span><br><span class="line">#方式二：</span><br><span class="line">	SELECT 字段 INTO 具备变量名</span><br><span class="line">	FROM 表;</span><br><span class="line">#③使用（查看变量的值）</span><br><span class="line">SELECT 局部变量名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#案例：声明两个变量，求和并打印</span><br><span class="line">#用户变量</span><br><span class="line">SET @m&#x3D;1;</span><br><span class="line">SET @n&#x3D;1;</span><br><span class="line">SET @sum&#x3D;@m+@n;</span><br><span class="line">SELECT @sum;</span><br><span class="line"></span><br><span class="line">#局部变量</span><br><span class="line">DECLARE m INT DEFAULT 1;</span><br><span class="line">DECLARE n INT DEFAULT 1;</span><br><span class="line">DECLARE SUM INT;</span><br><span class="line">SET SUM&#x3D;m+n;</span><br><span class="line">SELECT SUM;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户变量和局部变量的对比</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">				作用域				定义位置				语法</span><br><span class="line">用户变量		当前会话			会话的任何地方		加@符号，不用指定类型</span><br><span class="line">局部变量	定义它的<span class="keyword">BEGIN</span> <span class="keyword">END</span>中 	<span class="keyword">BEGIN</span> <span class="keyword">END</span>的第一句话	一般不用加@,需要指定类型</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><ul>
<li>说明：都类似于java中的方法，将一组完成特定功能的逻辑语句包装起来，对外暴露名字</li>
<li>好处<ul>
<li>1、提高代码的重用性</li>
<li>2、简化操作</li>
<li>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</li>
</ul>
</li>
</ul>
<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><ul>
<li>含义：一组预先编译好的SQL语句的集合，理解成批处理语句</li>
</ul>
<ul>
<li><p>创建语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  CREATE PROCEDURE 存储过程名(参数列表)</span><br><span class="line">  BEGIN</span><br><span class="line">  	存储过程体（一组合法的SQL语句）</span><br><span class="line">  END</span><br><span class="line">  </span><br><span class="line">  注意：</span><br><span class="line">  1、参数列表包含三部分</span><br><span class="line">  参数模式  参数名  参数类型</span><br><span class="line">  举例：</span><br><span class="line">  in stuname varchar(20)</span><br><span class="line">  </span><br><span class="line">  参数模式：</span><br><span class="line">  in：该参数可以作为输入，也就是该参数需要调用方传入值</span><br><span class="line">  out：该参数可以作为输出，也就是该参数可以作为返回值</span><br><span class="line">  inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</span><br><span class="line">  </span><br><span class="line">  2、如果存储过程体仅仅只有一句话，begin end可以省略</span><br><span class="line">  存储过程体中的每条sql语句的结尾要求必须加分号。</span><br><span class="line">  存储过程的结尾可以使用 delimiter 重新设置</span><br><span class="line">  语法：</span><br><span class="line">  delimiter 结束标记</span><br><span class="line">  案例：</span><br><span class="line">  delimiter $</span><br><span class="line"></span><br><span class="line">* 调用语法</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  CALL 存储过程名(实参列表);</span><br><span class="line">  </span><br><span class="line">  举例：</span><br><span class="line">  调用in模式的参数：call sp1（‘值’）;</span><br><span class="line">  调用out模式的参数：set @name; call sp1(@name);select @name;</span><br><span class="line">  调用inout模式的参数：set @name&#x3D;值; call sp1(@name); select @name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  #1.空参列表</span><br><span class="line">  #案例：插入到admin表中五条记录</span><br><span class="line">  </span><br><span class="line">  SELECT * FROM admin;</span><br><span class="line">  </span><br><span class="line">  DELIMITER $</span><br><span class="line">  CREATE PROCEDURE myp1()</span><br><span class="line">  BEGIN</span><br><span class="line">  	INSERT INTO admin(username,&#96;password&#96;) </span><br><span class="line">  	VALUES(&#39;john1&#39;,&#39;0000&#39;),(&#39;lily&#39;,&#39;0000&#39;),(&#39;rose&#39;,&#39;0000&#39;),(&#39;jack&#39;,&#39;0000&#39;),(&#39;tom&#39;,&#39;0000&#39;);</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  #调用</span><br><span class="line">  CALL myp1()$</span><br><span class="line">  </span><br><span class="line">  #2.创建带in模式参数的存储过程</span><br><span class="line">  </span><br><span class="line">  #案例1：创建存储过程实现 根据女神名，查询对应的男神信息</span><br><span class="line">  </span><br><span class="line">  CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))</span><br><span class="line">  BEGIN</span><br><span class="line">  	SELECT bo.*</span><br><span class="line">  	FROM boys bo</span><br><span class="line">  	RIGHT JOIN beauty b ON bo.id &#x3D; b.boyfriend_id</span><br><span class="line">  	WHERE b.name&#x3D;beautyName;</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  #调用</span><br><span class="line">  CALL myp2(&#39;柳岩&#39;)$</span><br><span class="line">  </span><br><span class="line">  #案例2 ：创建存储过程实现，用户是否登录成功</span><br><span class="line">  </span><br><span class="line">  CREATE PROCEDURE myp3(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))</span><br><span class="line">  BEGIN</span><br><span class="line">  	DECLARE result VARBINARY(20) DEFAULT &#39;&#39;;#声明并初始化</span><br><span class="line">  	</span><br><span class="line">  	SELECT COUNT(*) INTO result#赋值</span><br><span class="line">  	FROM admin</span><br><span class="line">  	WHERE admin.username &#x3D; username</span><br><span class="line">  	AND admin.password &#x3D; PASSWORD;</span><br><span class="line">  	</span><br><span class="line">  	SELECT result;#使用</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  CALL myp3(&#39;张飞&#39;,&#39;8888&#39;)$</span><br><span class="line">  </span><br><span class="line">  CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))</span><br><span class="line">  BEGIN</span><br><span class="line">  	DECLARE result INT DEFAULT 0;#声明并初始化</span><br><span class="line">  	</span><br><span class="line">  	SELECT COUNT(*) INTO result#赋值</span><br><span class="line">  	FROM admin</span><br><span class="line">  	WHERE admin.username &#x3D; username</span><br><span class="line">  	AND admin.password &#x3D; PASSWORD;</span><br><span class="line">  	</span><br><span class="line">  	SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);#使用</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  #调用</span><br><span class="line">  CALL myp4(&#39;张飞&#39;,&#39;8888&#39;)$</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #3.创建out 模式参数的存储过程</span><br><span class="line">  #案例1：根据输入的女神名，返回对应的男神名</span><br><span class="line">  </span><br><span class="line">  CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))</span><br><span class="line">  BEGIN</span><br><span class="line">  	SELECT bo.boyname INTO boyname</span><br><span class="line">  	FROM boys bo</span><br><span class="line">  	RIGHT JOIN</span><br><span class="line">  	beauty b ON b.boyfriend_id &#x3D; bo.id</span><br><span class="line">  	WHERE b.name&#x3D;beautyName ;</span><br><span class="line">  	</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  #案例2：根据输入的女神名，返回对应的男神名和魅力值</span><br><span class="line">  </span><br><span class="line">  CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) </span><br><span class="line">  BEGIN</span><br><span class="line">  	SELECT boys.boyname ,boys.usercp INTO boyname,usercp</span><br><span class="line">  	FROM boys </span><br><span class="line">  	RIGHT JOIN</span><br><span class="line">  	beauty b ON b.boyfriend_id &#x3D; boys.id</span><br><span class="line">  	WHERE b.name&#x3D;beautyName ;</span><br><span class="line">  	</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  #调用</span><br><span class="line">  CALL myp7(&#39;小昭&#39;,@name,@cp)$</span><br><span class="line">  SELECT @name,@cp$</span><br><span class="line">  </span><br><span class="line">  #4.创建带inout模式参数的存储过程</span><br><span class="line">  #案例1：传入a和b两个值，最终a和b都翻倍并返回</span><br><span class="line">  </span><br><span class="line">  CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)</span><br><span class="line">  BEGIN</span><br><span class="line">  	SET a&#x3D;a*2;</span><br><span class="line">  	SET b&#x3D;b*2;</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  #调用</span><br><span class="line">  SET @m&#x3D;10$</span><br><span class="line">  SET @n&#x3D;20$</span><br><span class="line">  CALL myp8(@m,@n)$</span><br><span class="line">  SELECT @m,@n$</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* 查看语法</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  show create procedure 存储过程名;</span><br><span class="line">  </span><br><span class="line">  案例</span><br><span class="line">  DESC myp2;×</span><br><span class="line">  SHOW CREATE PROCEDURE  myp2;</span><br><span class="line"></span><br><span class="line">* 删除语法</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  drop procedure 存储过程名;</span><br><span class="line">  </span><br><span class="line">  案例:</span><br><span class="line">  DROP PROCEDURE p1;</span><br><span class="line">  DROP PROCEDURE p2,p3;#×</span><br><span class="line"></span><br><span class="line">#### 函数</span><br><span class="line"></span><br><span class="line">- 含义：一组预先编译好的SQL语句的集合，理解成批处理语句</span><br><span class="line"></span><br><span class="line">- 区别：</span><br><span class="line"></span><br><span class="line">  - 存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新；</span><br><span class="line">  - 函数：有且仅有1 个返回，适合做处理数据后返回一个结果。*</span><br><span class="line"></span><br><span class="line">- 创建语法</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型</span><br><span class="line">  BEGIN</span><br><span class="line">  	函数体</span><br><span class="line">  END</span><br><span class="line">  </span><br><span class="line">  &#x2F;*</span><br><span class="line">  注意：</span><br><span class="line">  1.参数列表 包含两部分：</span><br><span class="line">  参数名 参数类型</span><br><span class="line">  2.函数体：肯定会有return语句，如果没有会报错</span><br><span class="line">  如果return语句没有放在函数体的最后也不报错，但不建议</span><br><span class="line">  </span><br><span class="line">  return 值;</span><br><span class="line">  3.函数体中仅有一句话，则可以省略begin end</span><br><span class="line">  4.使用 delimiter语句设置结束标记</span><br><span class="line">  *&#x2F;</span><br><span class="line">  </span><br><span class="line">  DELIMITER $</span><br><span class="line"></span><br><span class="line">* 调用语法</span><br><span class="line"></span><br><span class="line">  * SELECT 函数名(参数列表);</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  use employees $</span><br><span class="line">  #1.无参有返回</span><br><span class="line">  #案例：返回公司的员工个数</span><br><span class="line">  CREATE FUNCTION myf1() RETURNS INT</span><br><span class="line">  BEGIN	</span><br><span class="line">  	DECLARE c INT DEFAULT 0;</span><br><span class="line">  	SELECT COUNT(*) INTO c</span><br><span class="line">  	FROM employees;</span><br><span class="line">  	RETURN c;</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  SELECT myf1()$</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #2.有参有返回</span><br><span class="line">  #案例1：根据员工名，返回它的工资</span><br><span class="line">  </span><br><span class="line">  CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">  BEGIN</span><br><span class="line">  	SET @sal&#x3D;0;#定义用户变量 </span><br><span class="line">  	SELECT salary INTO @sal   #赋值</span><br><span class="line">  	FROM employees</span><br><span class="line">  	WHERE last_name &#x3D; empName;</span><br><span class="line">  	</span><br><span class="line">  	RETURN @sal;</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  SELECT myf2(&#39;kochhor&#39;) $</span><br><span class="line">  </span><br><span class="line">  #案例2：根据部门名，返回该部门的平均工资</span><br><span class="line">  </span><br><span class="line">  CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">  BEGIN</span><br><span class="line">  	DECLARE sal DOUBLE ;</span><br><span class="line">  	SELECT AVG(salary) INTO sal</span><br><span class="line">  	FROM employees e</span><br><span class="line">  	JOIN departments d ON e.department_id &#x3D; d.department_id</span><br><span class="line">  	WHERE d.department_name&#x3D;deptName;</span><br><span class="line">  	RETURN sal;</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  SELECT myf3(&#39;IT&#39;)$</span><br><span class="line"></span><br><span class="line">* 查看函数</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  show create function 函数名;</span><br><span class="line">  </span><br><span class="line">  SHOW CREATE FUNCTION myf3 $</span><br><span class="line"></span><br><span class="line">* 删除函数</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  drop function 函数名;</span><br><span class="line">  </span><br><span class="line">  DROP FUNCTION myf3 $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 流程控制结构</span><br><span class="line"></span><br><span class="line">- 顺序结构：程序从上往下依次执行</span><br><span class="line">- 分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行</span><br><span class="line">- 循环结构：程序满足一定条件下，重复执行一组语句</span><br><span class="line"></span><br><span class="line">#### 分支结构</span><br><span class="line"></span><br><span class="line">##### if函数</span><br><span class="line"></span><br><span class="line">- 语法：if(条件,值1，值2)；</span><br><span class="line">- 功能：实现双分支；</span><br><span class="line">- 应用：可以作为表达式放在任何位置</span><br><span class="line"></span><br><span class="line">##### case结构</span><br><span class="line"></span><br><span class="line">- 语法：</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  情况1：类似于switch，一般用于实现等值判断。</span><br><span class="line">  语法：</span><br><span class="line">  case 变量或表达式</span><br><span class="line">  when 值1 then 语句1;</span><br><span class="line">  when 值2 then 语句2;</span><br><span class="line">  ...</span><br><span class="line">  else 语句n;</span><br><span class="line">  end </span><br><span class="line">  </span><br><span class="line">  情况2：类似于多重if语句，一般用于实现区间判断。</span><br><span class="line">  语法：</span><br><span class="line">  case </span><br><span class="line">  when 条件1 then 语句1;</span><br><span class="line">  when 条件2 then 语句2;</span><br><span class="line">  ...</span><br><span class="line">  else 语句n;</span><br><span class="line">  end </span><br><span class="line"></span><br><span class="line">- 特点</span><br><span class="line"></span><br><span class="line">  * 可以作为表达式，嵌套在其他语句中使用。</span><br><span class="line">  * 可以放在任何地方，BEGIN END 中或BEGIN END 的外面可以作为独立的语句去使用，只能放在BEGIN END中如果wHEN中的值满足或条件成立，则执行对应的THzN后面的语句，并且结束CASE如果都不满足，则执行E1SE中的语句或值。</span><br><span class="line">  * ELSE可以省略，如果ELSE省略了，并且所有WHEN条件都不满足，则返回NULL。</span><br><span class="line"></span><br><span class="line">* 位置</span><br><span class="line">  * 可以放在任何位置，</span><br><span class="line">  * 如果放在begin end 外面，作为表达式结合着其他语句使用</span><br><span class="line">  * 如果放在begin end 里面，一般作为独立的语句使用</span><br><span class="line"></span><br><span class="line">* 案例</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  #创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩：90-100, 显示A，80-90，显示B，60-80，显示c，否则，显示D</span><br><span class="line">  </span><br><span class="line">  CREATE PROCEDURE test_case (IN score INT) </span><br><span class="line">  BEGIN </span><br><span class="line">  	CASE </span><br><span class="line">  	WHEN score&gt;&#x3D;90 AND score&lt;&#x3D;100 THEN SELECT &#39;A&#39;; </span><br><span class="line">  	WHEN score&gt;&#x3D;80 THEN SELECT &#39;B&#39;;</span><br><span class="line">  	WHEN score&gt;&#x3D;60 THEN SELECT &#39;C&#39;; </span><br><span class="line">  	ELSE SELECT &#39;D&#39;;</span><br><span class="line">  	END CASE; </span><br><span class="line">  END $</span><br><span class="line">  CALL test_case(95)$</span><br><span class="line"></span><br><span class="line">##### if结构</span><br><span class="line"></span><br><span class="line">- 语法：</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  if 条件1 then 语句1;</span><br><span class="line">  elseif 条件2 then 语句2;</span><br><span class="line">  ....</span><br><span class="line">  else 语句n;</span><br><span class="line">  end if;</span><br><span class="line"></span><br><span class="line">- 功能：类似于多重if；只能应用在begin end 中</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;&#96;mysql</span><br><span class="line">  #案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</span><br><span class="line">  </span><br><span class="line">  CREATE FUNCTION test_case(score FLOAT) RETURNS CHAR</span><br><span class="line">  BEGIN </span><br><span class="line">  	DECLARE ch CHAR DEFAULT &#39;A&#39;;</span><br><span class="line">  	</span><br><span class="line">  	CASE </span><br><span class="line">  	WHEN score&gt;90 THEN SET ch&#x3D;&#39;A&#39;;</span><br><span class="line">  	WHEN score&gt;80 THEN SET ch&#x3D;&#39;B&#39;;</span><br><span class="line">  	WHEN score&gt;60 THEN SET ch&#x3D;&#39;C&#39;;</span><br><span class="line">  	ELSE SET ch&#x3D;&#39;D&#39;;</span><br><span class="line">  	END CASE;</span><br><span class="line">  	</span><br><span class="line">  	RETURN ch;</span><br><span class="line">  END $</span><br><span class="line">  </span><br><span class="line">  SELECT test_case(56)$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul>
<li><p>位置：只能放在begin end中</p>
</li>
<li><p>特点：都能实现循环结构</p>
</li>
<li><p>语法</p>
<pre><code class="mysql">1、while
语法：
【名称:】while 循环条件 do
        循环体
end while 【名称】;
2、loop
语法：
【名称：】loop
        循环体
end loop 【名称】;

3、repeat
语法：
【名称:】repeat
        循环体
until 结束条件 
end repeat 【名称】;</code></pre>
</li>
<li><p>案例</p>
<pre><code class="mysql">#1.没有添加循环控制语句
#案例：批量插入，根据次数插入到admin表中多条记录
USE girls$
DROP PROCEDURE pro_while1$
CREATE PROCEDURE pro_while1(IN insertCount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i&lt;=insertCount DO
        INSERT INTO admin(username,`password`) VALUES(CONCAT(&#39;Rose&#39;,i),&#39;666&#39;);
        SET i=i+1;
    END WHILE;

END $

CALL pro_while1(158)$

select * from admin $
/*
int i=1;
while(i&lt;=insertcount)&#123;
    //插入
    i++;

&#125;
*/

#2.添加leave语句
#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止
TRUNCATE TABLE admin$
DROP PROCEDURE test_while1$
CREATE PROCEDURE test_while1(IN insertCount INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    a:WHILE i&lt;=insertCount DO
        INSERT INTO admin(username,`password`) VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);
        IF i&gt;=20 THEN LEAVE a;
        END IF;
        SET i=i+1;
    END WHILE a;
END $

CALL test_while1(100)$

select * from admin $

#3.添加iterate语句
#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次
TRUNCATE TABLE admin$
DROP PROCEDURE test_while1$
CREATE PROCEDURE test_while1(IN insertCount INT)
BEGIN
    DECLARE i INT DEFAULT 0;
    a:WHILE i&lt;=insertCount DO
        SET i=i+1;
        IF MOD(i,2)!=0 THEN ITERATE a;
        END IF;

        INSERT INTO admin(username,`password`) VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);

    END WHILE a;
END $

CALL test_while1(100)$

/*
int i=0;
while(i&lt;=insertCount)&#123;
    i++;
    if(i%2==0)&#123;
        continue;
    &#125;
    插入
&#125;
*/

select * from admin $</code></pre>
</li>
</ul>
<ul>
<li>循环控制语句<ul>
<li>leave：类似于break，用于跳出所在的循环</li>
<li>iterate：类似于continue，用于结束本次循环，继续下一次</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC核心技术</title>
    <url>/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/</url>
    <content><![CDATA[<h2 id="第1章：JDBC概述"><a href="#第1章：JDBC概述" class="headerlink" title="第1章：JDBC概述"></a>第1章：JDBC概述</h2><a id="more"></a>

<h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul>
<li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p>
</li>
<li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1566741430592.png"> </p>
</li>
</ul>
<h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul>
<li><p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li><p><strong>JDBC</strong>直接访问数据库</p>
</li>
<li><p>JDO (Java Data Object )技术</p>
</li>
<li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p>
</li>
</ul>
</li>
<li><p><strong>JDBC是java访问数据库的基石</strong>，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p>
</li>
</ul>
<h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul>
<li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li>
<li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
<li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555575760234.png"></p>
<p>​                                                                                            oracle                                             microsoft                       ibm</p>
<hr>
<ul>
<li>有了JDBC，Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555575981203.png" alt="1555575981203"></p>
<hr>
<ul>
<li>总结如下：</li>
<li>避免程序员对各个数据库相同操作不同代码</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1566741692804.png" alt="1566741692804"></p>
<h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul>
<li>JDBC接口（API）包括两个层次：<ul>
<li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li>
<li> <strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p>
<p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                            ————面向接口编程</strong></p>
</blockquote>
<ul>
<li>不同厂商设备 接口的实现集合就是驱动</li>
</ul>
<h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1565969323908.png" alt="1565969323908"></p>
<blockquote>
<p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p>
</blockquote>
<h2 id="第2章：获取数据库连接"><a href="#第2章：获取数据库连接" class="headerlink" title="第2章：获取数据库连接"></a>第2章：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类（driver-驱动）"><a href="#2-1-要素一：Driver接口实现类（driver-驱动）" class="headerlink" title="2.1 要素一：Driver接口实现类（driver=驱动）"></a>2.1 要素一：Driver接口实现类（driver=驱动）</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul>
<li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p>
</li>
<li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p>
<ul>
<li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li>
<li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li>
</ul>
</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555576157618.png" alt="1555576157618"></p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555576170074.png" alt="1555576170074"></p>
<ul>
<li><p>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹directory。</p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1566134718955.png" alt="1566134718955"></p>
</li>
</ul>
<p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path（idea：add as library）</p>
<p> <img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1566134781682.png" alt="1566134781682"></p>
<p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p>
<p> <img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1566135290460.png" alt="1566135290460"></p>
<h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul>
<li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p>
<ul>
<li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li>
</ul>
</li>
<li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p>
<ul>
<li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p>
</li>
<li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1566136831283.png" alt="1566136831283"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-要素二：URL（统一资源定位符）"><a href="#2-2-要素二：URL（统一资源定位符）" class="headerlink" title="2.2 要素二：URL（统一资源定位符）"></a>2.2 要素二：URL（统一资源定位符）</h3><ul>
<li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p>
</li>
<li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p>
<ul>
<li><p><strong>jdbc:子协议:子名称</strong></p>
</li>
<li><p><strong>协议</strong>：JDBC URL中的协议总是jdbc </p>
</li>
<li><p><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</p>
</li>
<li><p><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></p>
</li>
<li><p>举例：                                                                                                              IP地址        端口号    数据库库名</p>
</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555576477107.png" alt="1555576477107"></p>
</li>
<li><p><strong>几种常用数据库的 JDBC URL</strong></p>
<ul>
<li><p>MySQL的连接URL编写方式：</p>
<ul>
<li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li>
<li>jdbc:mysql://localhost:3306/atguigu</li>
<li>jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li>
<li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li>
</ul>
</li>
<li><p>Oracle 9i的连接URL编写方式：</p>
<ul>
<li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li>
<li>jdbc:oracle:thin:@localhost:1521:atguigu</li>
</ul>
</li>
<li><p>SQLServer的连接URL编写方式：</p>
<ul>
<li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p>
</li>
<li><p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul>
<li>user,password可以用“属性名=属性值”方式告诉数据库</li>
<li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li>
</ul>
<h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">           Driver driver = <span class="keyword">null</span>;</span><br><span class="line">           driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上述代码中显式出现了第三方数据库的API                         com.mysql.jdbc.JDBC4Connection@7cef4e59</p>
</blockquote>
<h4 id="2-4-2-连接方式二（改方式一）"><a href="#2-4-2-连接方式二（改方式一）" class="headerlink" title="2.4.2 连接方式二（改方式一）"></a>2.4.2 连接方式二（改方式一）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.使用反射获取Driver实现类对象</span></span><br><span class="line">           String className = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">           Class clazz = Class.forName(className);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p>
</blockquote>
<h4 id="2-4-3-连接方式三（改方式二）"><a href="#2-4-3-连接方式三（改方式二）" class="headerlink" title="2.4.3 连接方式三（改方式二）"></a>2.4.3 连接方式三（改方式二）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           Class clazz = Class.forName(driverName);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动****可以省略这一步 在getConnection里封装了</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p>
</blockquote>
<h4 id="2-4-4-连接方式四-改方式三"><a href="#2-4-4-连接方式四-改方式三" class="headerlink" title="2.4.4 连接方式四(改方式三)"></a>2.4.4 连接方式四(改方式三)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">           Class.forName(driverName);<span class="comment">//类的加载 driver实现类里静态代码块随着类加载进行</span></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">           <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">           static &#123;</span></span><br><span class="line"><span class="comment">               try &#123;</span></span><br><span class="line"><span class="comment">                   DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">               &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                   throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：不必显式的注册驱动了。因为在mysql的driver实现类的源码中已经存在静态代码块，实现了驱动的注册。</p>
</blockquote>
<h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)***"></a>2.4.5 连接方式五(最终版)***</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   	<span class="comment">//1.加载配置文件                        类的加载器</span></span><br><span class="line">       InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);<span class="comment">//或者用ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)</span></span><br><span class="line">       Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">       pros.load(is);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.读取配置信息</span></span><br><span class="line">       String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">       String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.加载驱动</span></span><br><span class="line">       Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.获取连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">       System.out.println(conn);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不要加空格，避免歧义</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p>
<p><strong>使用配置文件的好处：</strong></p>
<p>①实现了代码和数据的分离（解耦），如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程，不需要动主程序的代码。</p>
</blockquote>
<h2 id="第3章：使用PreparedStatement实现CRUD操作"><a href="#第3章：使用PreparedStatement实现CRUD操作" class="headerlink" title="第3章：使用PreparedStatement实现CRUD操作"></a>第3章：使用PreparedStatement实现CRUD操作</h2><p>（create，retrieve，update，delete）</p>
<h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul>
<li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p>
</li>
<li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p>
<ul>
<li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 ×</li>
<li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li>
<li>CallableStatement：用于执行 SQL 存储过程</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1566573842140.png" alt="1566573842140"></p>
</li>
</ul>
<h3 id="3-2-使用Statement操作数据表的弊端"><a href="#3-2-使用Statement操作数据表的弊端" class="headerlink" title="3.2 使用Statement操作数据表的弊端"></a>3.2 使用Statement操作数据表的弊端</h3><ul>
<li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p>
</li>
<li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">int excuteUpdate(String sql)：执行更新操作<span class="keyword">INSERT</span>、<span class="keyword">UPDATE</span>、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(<span class="keyword">String</span> <span class="keyword">sql</span>)：执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但是使用Statement操作数据表存在弊端：</p>
<ul>
<li><strong>问题一：存在拼串操作，繁琐</strong></li>
<li><strong>问题二：存在SQL注入问题</strong></li>
</ul>
</li>
<li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p>
</li>
<li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p>
</li>
<li><p>代码演示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">		System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">		String userName = scan.nextLine();</span><br><span class="line">		System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line">		String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line">		String sql = <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">				+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">		User user = get(sql, User.class);</span><br><span class="line">		<span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上：</p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1566569819744.png" alt="1566569819744"></p>
<h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul>
<li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p>
</li>
<li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p>
</li>
<li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p>
</li>
</ul>
<h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul>
<li>PreparedStatement是Statement子接口   功能是传送sql语句到数据库进行操作</li>
<li>PreparedStatement可以操作Blob的数据，Statement不行</li>
<li><strong>PreparedStatement 能最大可能提高性能：</strong><ul>
<li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u>（可批量操作，如插入一万条数据）</li>
<li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li>
<li>(语法检查，语义检查，翻译成二进制命令，缓存)</li>
</ul>
</li>
<li>PreparedStatement 可以防止 SQL 注入 ，预编译，通过占位符填充数据</li>
</ul>
<h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table>
<thead>
<tr>
<th>Java类型</th>
<th>SQL类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>String</td>
<td>CHAR,VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>byte   array</td>
<td>BINARY  ,    VAR BINARY</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
</tbody></table>
<h4 id="3-3-4-使用PreparedStatement实现增、删、改操作"><a href="#3-3-4-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.4 使用PreparedStatement实现增、删、改操作"></a>3.3.4 使用PreparedStatement实现增、删、改操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql,Object ... args)</span></span>&#123;<span class="comment">//通用    Object ... args 动态参数 可有多个形参</span></span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//1.获取数据库的连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);   <span class="comment">//例如sql=&quot;insert into customers(name,email,birth) values(?,?,?)&quot; ?占位符</span></span><br><span class="line">           <span class="comment">//注意：sql语句里如果表名、参数是关键字等 要`order`加反引号</span></span><br><span class="line">		<span class="comment">//3.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);<span class="comment">//例如ps.setObject(1,&quot;gewen&quot;);</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4.执行sql语句</span></span><br><span class="line">		ps.execute();<span class="comment">//如果想要返回update改动行数 return ps.executeUpdate();</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//5.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(conn, ps);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String sql = <span class="string">&quot;delete from customers where id = ?&quot;</span>;</span><br><span class="line">       update(sql,<span class="number">3</span>);<span class="comment">//3代表第一个？,占位符,args[0]为3</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把连接和关闭封装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取数据库连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//用throws不用try-catch 因为一个一个方法用throws，避免出错但仍返回后，调用的主程序继续执行</span></span><br><span class="line">        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">        pros.load(is);</span><br><span class="line">        String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driver = pros.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        Connection connect = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭连接和statement</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeResource</span><span class="params">(Connection conn, Statement ps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>)</span><br><span class="line">                ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>)</span><br><span class="line">                conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭连接、statement和查询结果集的ResultSet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeResource</span><span class="params">(Connection conn, Statement ps, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span>)</span><br><span class="line">                ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>)</span><br><span class="line">                conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="keyword">null</span>)</span><br><span class="line">                rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5-使用PreparedStatement实现查询操作"><a href="#3-3-5-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.5 使用PreparedStatement实现查询操作"></a>3.3.5 使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">		rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line">		ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6.1通过ResultSetMetaData得到columnCount列值,columnLabel；</span></span><br><span class="line">		<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">           ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;();<span class="comment">//每个元素代表一行数据对象</span></span><br><span class="line">		<span class="keyword">while</span> (rs.next()) &#123;<span class="comment">//rs.next进行换行</span></span><br><span class="line">			T t = clazz.newInstance();<span class="comment">//每一行一个对象</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 当前行中遍历每一个列</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 获取具体值</span></span><br><span class="line">				Object value = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 获取列的别名:列的别名，使用类的属性名充当  因为存在类属性名和数据库列名不同，通过结果集元数据在中间</span></span><br><span class="line">				String columnLabel = rsmd.getColumnLabel(i + <span class="number">1</span>);<span class="comment">//不用getColumnName</span></span><br><span class="line">				<span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line">				Field field = clazz.getDeclaredField(columnLabel);<span class="comment">//获取类中与列名或别名相同的属性</span></span><br><span class="line">				field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">				field.set(t, value);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			list.add(t);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">           </span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 7.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select id,name,email from customers where id = ?&quot;</span>;</span><br><span class="line">        customer instance = getInstance(customer.class, sql, <span class="number">2</span>);</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span><span class="comment">//多行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select id,name,email from customers where id &lt; ?&quot;</span>;</span><br><span class="line">        List&lt;customer&gt; instance = getInstance(customer.class, sql, <span class="number">4</span>);</span><br><span class="line">        instance.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p>
</blockquote>
<h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul>
<li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p>
</li>
<li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p>
</li>
<li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p>
</li>
<li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p>
</li>
<li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p>
<ul>
<li>例如: getInt(1), getString(“name”)</li>
<li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li>
</ul>
</li>
<li><p>ResultSet 接口的常用方法：</p>
<ul>
<li><p>boolean next()</p>
</li>
<li><p>getString()</p>
</li>
<li><p>…</p>
</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555580152530.png" alt="1555580152530"></p>
</li>
</ul>
<h4 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h4><ul>
<li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p>
</li>
<li><p>ResultSetMetaData meta = rs.getMetaData();</p>
<ul>
<li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p>
</li>
<li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p>
</li>
<li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p>
</li>
<li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p>
</li>
<li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p>
</li>
<li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p>
</li>
<li><p> isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555579494691.png" alt="1555579494691"></p>
<p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p>
<p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p>
<p><strong>问题2：关于ResultSetMetaData</strong></p>
<ol>
<li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li>
<li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li>
<li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li>
</ol>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555579816884.png" alt="1555579816884"></p>
<h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul>
<li>释放ResultSet, Statement,Connection。</li>
<li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li>
<li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li>
</ul>
<h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul>
<li><p>两种思想</p>
<ul>
<li>面向接口编程的思想<ul>
<li>返回值是接口，实际返回的是mysql具体的实现类</li>
</ul>
</li>
<li>ORM思想(object relational mapping)<ul>
<li>一个数据表对应一个java类</li>
<li>表中的一条记录对应java类的一个对象</li>
<li>表中的一个字段对应java类的一个属性</li>
</ul>
</li>
</ul>
<blockquote>
<p>sql是需要结合列名和表的属性名来写。注意起别名。</p>
</blockquote>
</li>
<li><p>两种技术</p>
<ul>
<li>JDBC结果集的元数据：ResultSetMetaData<ul>
<li>获取列数：getColumnCount()</li>
<li>获取列的别名：getColumnLabel()</li>
</ul>
</li>
<li>通过反射，创建指定类的对象，获取指定的属性并赋值</li>
</ul>
</li>
</ul>
<hr>
<h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555580275036.png" alt="1555580275036"></p>
<ul>
<li>ps.execute:执行的是查询，有返回结果，返回true；执行增删改操作，没有返回结果，返回false</li>
<li>ps .executeUpdate:返回影响的条数int型数</li>
</ul>
<p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555580735377.png" alt="1555580735377"></p>
<p>向数据表中添加如下数据：</p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555580763636.png" alt="1555580763636"></p>
<p><strong>代码实现1：插入一个新的student 信息</strong></p>
<p>请输入考生的详细信息</p>
<p>Type:<br>IDCard:<br>ExamCard:<br>StudentName:<br>Location:<br>Grade:</p>
<p>信息录入成功!</p>
<p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555580937490.png" alt="1555580937490"></p>
<p><strong>代码实现3：完成学生信息的删除功能</strong></p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555580965019.png" alt="1555580965019"></p>
<hr>
<h2 id="第4章-操作BLOB类型字段"><a href="#第4章-操作BLOB类型字段" class="headerlink" title="第4章 操作BLOB类型字段"></a>第4章 操作BLOB类型字段</h2><h3 id="4-1-MySQL-BLOB类型"><a href="#4-1-MySQL-BLOB类型" class="headerlink" title="4.1 MySQL BLOB类型"></a>4.1 MySQL BLOB类型</h3><ul>
<li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p>
</li>
<li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p>
</li>
<li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p>
</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555581069798.png" alt="1555581069798"></p>
<ul>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li>
<li><strong>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li>
</ul>
<h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">String sql = <span class="string">&quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;徐海强&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">&quot;xhq@126.com&quot;</span>);</span><br><span class="line">ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(<span class="keyword">new</span> java.util.Date().getTime()));</span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xhq.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>, fis);</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">ps.execute();</span><br><span class="line">		</span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">String sql = <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;coffee.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>, fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>



<h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">	Integer id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">	String email = rs.getString(<span class="number">3</span>);</span><br><span class="line">    Date birth = rs.getDate(<span class="number">4</span>);</span><br><span class="line">	Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">    System.out.println(cust); </span><br><span class="line">    <span class="comment">//读取Blob类型的字段</span></span><br><span class="line">	Blob photo = rs.getBlob(<span class="number">5</span>);</span><br><span class="line">	InputStream is = photo.getBinaryStream();<span class="comment">//二进制流</span></span><br><span class="line">	OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c.jpg&quot;</span>);</span><br><span class="line">	<span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">		os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">	&#125;</span><br><span class="line">    JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">		is.close();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(os !=  <span class="keyword">null</span>)&#123;</span><br><span class="line">		os.close();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第5章-批量插入"><a href="#第5章-批量插入" class="headerlink" title="第5章 批量插入"></a>第5章 批量插入</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p>
<p>JDBC的批量处理语句包括下面三个方法：</p>
<ul>
<li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li>
<li><strong>executeBatch()：执行批量处理语句；</strong></li>
<li><strong>clearBatch():清空缓存的数据</strong></li>
</ul>
<p>通常我们会遇到两种批量执行SQL语句的情况：</p>
<ul>
<li>多条SQL语句的批量处理；</li>
<li>一个SQL语句的批量传参；</li>
</ul>
<h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p>
<ul>
<li>数据库中提供一个goods表。创建如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;</span><br><span class="line">	st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">	ps.executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 修改1： 使用 addBatch() / executeBatch() / clearBatch()</span></span><br><span class="line"><span class="comment"> * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。</span></span><br><span class="line"><span class="comment"> * 		 ?rewriteBatchedStatements=true 写在配置文件的url后面</span></span><br><span class="line"><span class="comment"> * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">	Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">//3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//20000条：625                                                                         //1000000条:14733  </span></span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 层次四：在层次三的基础上操作</span></span><br><span class="line"><span class="comment">* 使用Connection 的 setAutoCommit(false)  /  commit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">	Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//1.设置为不自动提交数据</span></span><br><span class="line">	conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">//3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//2.提交数据</span></span><br><span class="line">	conn.commit();</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第6章：-数据库事务"><a href="#第6章：-数据库事务" class="headerlink" title="第6章： 数据库事务"></a>第6章： 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul>
<li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p>
</li>
<li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都<strong>被提交(commit)**，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务</strong>回滚(rollback)**到最初状态。</p>
</li>
<li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p>
</li>
</ul>
<h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul>
<li><p>数据一旦提交，就不可回滚。</p>
</li>
<li><p>数据什么时候意味着提交？</p>
<ul>
<li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li>
</ul>
</li>
<li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p>
<ul>
<li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li>
<li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li>
</ul>
<blockquote>
<p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p>
</blockquote>
</li>
</ul>
<p>【案例：用户AA向用户BB转账100】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dml会自动提交，connection断开连接自动提交，不要自动提交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		<span class="comment">// 2.开启事务</span></span><br><span class="line">		conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 3.进行数据库操作</span></span><br><span class="line">		String sql1 = <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">		update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟网络异常</span></span><br><span class="line">		<span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line">		String sql2 = <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">		update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">		<span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">		conn.commit();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">			conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//7.关闭连接</span></span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，对数据库操作的方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）把连接放在外面进行，不然执行一次更新，连接关闭一次就会提交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> </span>&#123;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">// 2.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3.执行sql语句</span></span><br><span class="line">		ps.execute();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 4.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(<span class="keyword">null</span>, ps);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a>6.3 事务的ACID属性</h3><ol>
<li><p><strong>原子性（Atomicity）</strong><br> 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p>
</li>
<li><p><strong>一致性（Consistency）</strong><br> 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong><br> 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性（Durability）</strong><br> 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</li>
</ol>
<h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><ul>
<li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
</li>
<li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>
</li>
<li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p>
</li>
</ul>
<h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><ul>
<li><p>数据库提供的4种事务隔离级别：</p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555586275271.png" alt="1555586275271"></p>
</li>
<li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p>
</li>
</ul>
<ul>
<li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li>
</ul>
<h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 在MySql中设置隔离级别</h4><ul>
<li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p>
</li>
<li><p>查看当前的隔离级别: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置当前 mySQL 连接的隔离级别:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据库系统的全局的隔离级别:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure>
</li>
<li><p>补充操作：</p>
<ul>
<li><p>创建mysql数据库用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user tom identified by &#39;abc123&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>授予权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privileges on *.* to tom@&#39;%&#39;  identified by &#39;abc123&#39;; </span><br><span class="line"></span><br><span class="line"> #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#39;abc123&#39;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h2 id="第7章：DAO及相关实现类"><a href="#第7章：DAO及相关实现类" class="headerlink" title="第7章：DAO及相关实现类"></a>第7章：DAO及相关实现类</h2><ul>
<li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li>
<li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li>
</ul>
<h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><p>DAO: data(base) access object：封装了针对于数据表的通用的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BaseDao</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">package</span> com.atguigu2.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSetMetaData;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu1.util.JDBCUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAO: data(base) access object</span></span><br><span class="line"><span class="comment"> * 封装了针对于数据表的通用的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDAO</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 通用的增删改操作---version 2.0 （考虑上事务）</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn, String sql, Object... args)</span> </span>&#123;<span class="comment">// sql中占位符的个数与可变形参的长度相同！</span></span><br><span class="line">		PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1.预编译sql语句，返回PreparedStatement的实例</span></span><br><span class="line">			ps = conn.prepareStatement(sql);</span><br><span class="line">			<span class="comment">// 2.填充占位符</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">				ps.setObject(i + <span class="number">1</span>, args[i]);<span class="comment">// 小心参数声明错误！！</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.执行</span></span><br><span class="line">			<span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 4.资源的关闭</span></span><br><span class="line">			JDBCUtils.closeResource(<span class="keyword">null</span>, ps);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通用的查询操作，用于返回数据表中的一条记录（version 2.0：考虑上事务）</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args)</span> </span>&#123;</span><br><span class="line">		PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">		ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			ps = conn.prepareStatement(sql);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">				ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			rs = ps.executeQuery();</span><br><span class="line">			<span class="comment">// 获取结果集的元数据 :ResultSetMetaData</span></span><br><span class="line">			ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">			<span class="comment">// 通过ResultSetMetaData获取结果集中的列数</span></span><br><span class="line">			<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">				T t = clazz.newInstance();</span><br><span class="line">				<span class="comment">// 处理结果集一行数据中的每一个列</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">					<span class="comment">// 获取列值</span></span><br><span class="line">					Object columValue = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 获取每个列的列名</span></span><br><span class="line">					<span class="comment">// String columnName = rsmd.getColumnName(i + 1);</span></span><br><span class="line">					String columnLabel = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 给t对象指定的columnName属性，赋值为columValue：通过反射</span></span><br><span class="line">					Field field = clazz.getDeclaredField(columnLabel);</span><br><span class="line">					field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">					field.set(t, columValue);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			JDBCUtils.closeResource(<span class="keyword">null</span>, ps, rs);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通用的查询操作，用于返回数据表中的多条记录构成的集合（version 2.0：考虑上事务）</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getForList</span><span class="params">(Connection conn, Class&lt;T&gt; clazz, String sql, Object... args)</span> </span>&#123;</span><br><span class="line">		PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">		ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			ps = conn.prepareStatement(sql);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">				ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			rs = ps.executeQuery();</span><br><span class="line">			<span class="comment">// 获取结果集的元数据 :ResultSetMetaData</span></span><br><span class="line">			ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">			<span class="comment">// 通过ResultSetMetaData获取结果集中的列数</span></span><br><span class="line">			<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">			<span class="comment">// 创建集合对象</span></span><br><span class="line">			ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">			<span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">				T t = clazz.newInstance();</span><br><span class="line">				<span class="comment">// 处理结果集一行数据中的每一个列:给t对象指定的属性赋值</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">					<span class="comment">// 获取列值</span></span><br><span class="line">					Object columValue = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 获取每个列的列名</span></span><br><span class="line">					<span class="comment">// String columnName = rsmd.getColumnName(i + 1);</span></span><br><span class="line">					String columnLabel = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 给t对象指定的columnName属性，赋值为columValue：通过反射</span></span><br><span class="line">					Field field = clazz.getDeclaredField(columnLabel);</span><br><span class="line">					field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">					field.set(t, columValue);</span><br><span class="line">				&#125;</span><br><span class="line">				list.add(t);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			JDBCUtils.closeResource(<span class="keyword">null</span>, ps, rs);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用于查询特殊值的通用的方法</span></span><br><span class="line">	<span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">getValue</span><span class="params">(Connection conn,String sql,Object...args)</span></span>&#123;</span><br><span class="line">		PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">		ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ps = conn.prepareStatement(sql);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">				ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			rs = ps.executeQuery();</span><br><span class="line">			<span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">				<span class="keyword">return</span> (E) rs.getObject(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			JDBCUtils.closeResource(<span class="keyword">null</span>, ps, rs);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1566726681515.png" alt="1566726681515"></p>
<ul>
<li>层次结构：</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1566745811244.png" alt="1566745811244"></p>
<h3 id="【BaseDAO-java】-1"><a href="#【BaseDAO-java】-1" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HanYanBing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	<span class="comment">// 定义一个变量来接收泛型的类型</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BaseDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取子类的类型</span></span><br><span class="line">		Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">		<span class="comment">// 获取父类的类型</span></span><br><span class="line">		<span class="comment">// getGenericSuperclass()用来获取当前类的父类的类型</span></span><br><span class="line">		<span class="comment">// ParameterizedType表示的是带泛型的类型</span></span><br><span class="line">		ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();</span><br><span class="line">		<span class="comment">// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型</span></span><br><span class="line">		<span class="comment">// 这个方法会返回一个Type的数组</span></span><br><span class="line">		Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">		<span class="comment">// 获取具体的泛型的类型·</span></span><br><span class="line">		<span class="keyword">this</span>.type = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通用的增删改操作</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			count = queryRunner.update(conn, sql, params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取一个对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getBean</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取所有对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getBeanList</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			list = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		Object count = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 调用queryRunner的query方法获取一个单一的值</span></span><br><span class="line">			count = queryRunner.query(conn, sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;(), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库中查询出所有的记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数据库中插入一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库中根据图书的id删除一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据图书的id从数据库中查询出一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据图书的id从数据库中更新一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取带分页的图书信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取带分页和价格范围的图书信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据User对象中的用户名和密码从数据库中获取一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据User对象中的用户名从数据库中获取一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数据库中插入User对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;<span class="comment">//具体表的实现类都继承BaseDao，用basedao中方法实现基本的</span></span><br><span class="line"><span class="comment">//指明泛型Book类</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中得到一个List的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;</span>;</span><br><span class="line">		beanList = getBeanList(conn,sql);</span><br><span class="line">		<span class="keyword">return</span> beanList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;DELETE FROM books WHERE id = ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用增删改的方法</span></span><br><span class="line">		update(conn,sql, bookId);</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		Book book = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;</span>;</span><br><span class="line">		book = getBean(conn,sql, bookId);</span><br><span class="line">		<span class="keyword">return</span> book;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">		String sql = <span class="string">&quot;select count(*) from books&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line">		<span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql);</span><br><span class="line">		<span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">		page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">		String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line">		<span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">		page.setList(beanList);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">		String sql = <span class="string">&quot;select count(*) from books where price between ? and ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line">		<span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql,minPrice,maxPrice);</span><br><span class="line">		<span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">		page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">		String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line">		<span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">		page.setList(beanList);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		User bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,username,password,email from users where username = ? and password = ?&quot;</span>;</span><br><span class="line">		bean = getBean(conn,sql, user.getUsername(), user.getPassword());</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		User bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,username,password,email from users where username = ?&quot;</span>;</span><br><span class="line">		bean = getBean(conn,sql, user.getUsername());</span><br><span class="line">		<span class="keyword">return</span> bean != <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into users(username,password,email) values(?,?,?)&quot;</span>;</span><br><span class="line">		<span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String title; <span class="comment">// 书名</span></span><br><span class="line">	<span class="keyword">private</span> String author; <span class="comment">// 作者</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> price; <span class="comment">// 价格</span></span><br><span class="line">	<span class="keyword">private</span> Integer sales; <span class="comment">// 销量</span></span><br><span class="line">	<span class="keyword">private</span> Integer stock; <span class="comment">// 库存</span></span><br><span class="line">	<span class="keyword">private</span> String imgPath = <span class="string">&quot;static/img/default.jpg&quot;</span>; <span class="comment">// 封面图片的路径</span></span><br><span class="line">	<span class="comment">//构造器，get()，set()，toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页码类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_SIZE = <span class="number">4</span>; <span class="comment">// 每页显示的记录数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> pageNo; <span class="comment">// 当前页</span></span><br><span class="line"><span class="comment">//	private int totalPageNo; // 总页数，通过计算得到</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> totalRecord; <span class="comment">// 总记录数，通过查询数据库得到</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第8章：数据库连接池"><a href="#第8章：数据库连接池" class="headerlink" title="第8章：数据库连接池"></a>第8章：数据库连接池</h2><h3 id="8-1-JDBC数据库连接池的必要性"><a href="#8-1-JDBC数据库连接池的必要性" class="headerlink" title="8.1 JDBC数据库连接池的必要性"></a>8.1 JDBC数据库连接池的必要性</h3><ul>
<li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p>
<ul>
<li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li>
<li><strong>进行sql操作</strong></li>
<li><strong>断开数据库连接</strong></li>
</ul>
</li>
<li><p>这种模式开发，存在的问题:</p>
<ul>
<li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？：无用对象持续占用内存）</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li>
</ul>
</li>
</ul>
<h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul>
<li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
</li>
<li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p>
</li>
<li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p>
</li>
<li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555593464033.png" alt="1555593464033"></p>
<ul>
<li><strong>工作原理：</strong></li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555593598606.png" alt="1555593598606"></p>
<ul>
<li><p><strong>数据库连接池技术的优点</strong></p>
<p><strong>1. 资源重用</strong></p>
<p>由于数据库连接得以<strong>重复利用</strong>，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p><strong>2. 更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往<strong>已经创建了若干数据库连接置于连接池中备用</strong>。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p>
<p><strong>3. 新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，<strong>可在应用层通过数据库连接池的配置</strong>，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p>
<p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p>
</li>
</ul>
<h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul>
<li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul>
<li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。hibernate官方推荐使用</strong></li>
<li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li>
<li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li>
<li><strong><em>Druid</em></strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li>
</ul>
</li>
<li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li>
<li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li>
<li>特别注意：<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
</li>
</ul>
<h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><ul>
<li>获取连接方式一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">	cpds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">	cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">	cpds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	cpds.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//	cpds.setMaxPoolSize(100);</span></span><br><span class="line">	</span><br><span class="line">	Connection conn = cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>获取连接方式二*</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource cpds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;helloc3p0&quot;</span>);<span class="comment">//不能放在方法里面，只要一个连接池</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">		Connection conn = cpds.getConnection();</span><br><span class="line">		<span class="keyword">return</span> conn;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【c3p0-config.xml】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-2-DBCP数据库连接池"><a href="#8-3-2-DBCP数据库连接池" class="headerlink" title="8.3.2 DBCP数据库连接池"></a>8.3.2 DBCP数据库连接池</h4><ul>
<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
<li>配置属性说明</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>initialSize</td>
<td>0</td>
<td>连接池启动时创建的初始化连接数量</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>连接池中可同时连接的最大的连接数</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td>
</tr>
<tr>
<td>minIdle</td>
<td>0</td>
<td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td>
</tr>
<tr>
<td>maxWait</td>
<td>无限制</td>
<td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>开启池的Statement是否prepared</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>无限制</td>
<td>开启池的prepared 后的同时最大连接数</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>300</td>
<td>超过时间限制，回收没有用(废弃)的连接</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>false</td>
<td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td>
</tr>
</tbody></table>
<ul>
<li>获取连接方式一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	BasicDataSource source = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">		</span><br><span class="line">	source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">	source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">	source.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	source.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	source.setInitialSize(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取连接方式二：*</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> DataSource source = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;<span class="comment">//静态代码块，只随类加载运行一次，产生一个连接池</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">            InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//或者FileInputStream is = new FileInputStream(new File(&quot;src/dbcp.properties&quot;));</span></span><br><span class="line">            pros.load(is);</span><br><span class="line">            <span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">            source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection conn = source.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【dbcp.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource source = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;<span class="comment">//静态代码块，只随类加载运行一次，产生一个连接池</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();		</span><br><span class="line">            </span><br><span class="line">            pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">            DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">      	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Connection conn = ds.getConnection();</span><br><span class="line">		<span class="keyword">return</span> conn;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【druid.properties】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">maxWait=<span class="number">1000</span></span><br><span class="line">filters=wall</span><br></pre></td></tr></table></figure>

<ul>
<li>详细配置参数：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>配置</strong></th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
<h2 id="第9章：Apache-DBUtils实现CRUD操作"><a href="#第9章：Apache-DBUtils实现CRUD操作" class="headerlink" title="第9章：Apache-DBUtils实现CRUD操作"></a>第9章：Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils简介"><a href="#9-1-Apache-DBUtils简介" class="headerlink" title="9.1 Apache-DBUtils简介"></a>9.1 Apache-DBUtils简介</h3><ul>
<li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是<strong>对JDBC的简单封装</strong>，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p>
</li>
<li><p>API介绍：</p>
<ul>
<li>org.apache.commons.dbutils.QueryRunner</li>
<li>org.apache.commons.dbutils.ResultSetHandler</li>
<li>工具类：org.apache.commons.dbutils.DbUtils   </li>
</ul>
</li>
<li><p>API包说明：</p>
</li>
</ul>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555595163263.png" alt="1555595163263"></p>
<p><img src="/2021/06/10/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC.assets/1555595198644.png" alt="1555595198644"></p>
<h3 id="9-2-主要API的使用"><a href="#9-2-主要API的使用" class="headerlink" title="9.2 主要API的使用"></a>9.2 主要API的使用</h3><h4 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h4><ul>
<li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul>
<li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li>
<li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li>
<li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li>
<li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li>
<li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li>
<li>public static void rollbackAndClose(Connection conn)throws SQLException</li>
<li>rollbackAndCloseQuietly(Connection)</li>
<li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li>
</ul>
</li>
</ul>
<h4 id="9-2-2-QueryRunner类"><a href="#9-2-2-QueryRunner类" class="headerlink" title="9.2.2 QueryRunner类"></a>9.2.2 QueryRunner类</h4><ul>
<li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p>
</li>
<li><p>QueryRunner类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
</li>
<li><p>QueryRunner类的主要方法：</p>
<ul>
<li><strong>更新</strong><ul>
<li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li>
<li> ……</li>
</ul>
</li>
<li><strong>插入</strong><ul>
<li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</T></T></li>
<li>….</li>
</ul>
</li>
<li><strong>批处理</strong><ul>
<li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li>
<li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</T></T></li>
<li>…..</li>
</ul>
</li>
<li><strong>查询</strong><ul>
<li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li>
<li>…… </li>
</ul>
</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">	String sql = <span class="string">&quot;insert into customers(name,email,birth)values(?,?,?)&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> count = runner.update(conn, sql, <span class="string">&quot;何成飞&quot;</span>, <span class="string">&quot;he@qq.com&quot;</span>, <span class="string">&quot;1992-09-08&quot;</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;添加了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">	String sql = <span class="string">&quot;delete from customers where id &lt; ?&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> count = runner.update(conn, sql,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;删除了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-2-3-ResultSetHandler接口及实现类"><a href="#9-2-3-ResultSetHandler接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler接口及实现类"></a>9.2.3 ResultSetHandler接口及实现类</h4><ul>
<li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>
</li>
<li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p>
</li>
<li><p>接口的主要实现类：</p>
<ul>
<li><p>ArrayHandler：把结果集中的第一行数据转成对象数组。</p>
</li>
<li><p>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</p>
</li>
<li><p><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</p>
</li>
<li><p><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</p>
</li>
<li><p>ColumnListHandler：将结果集中某一列的数据存放到List中。</p>
</li>
<li><p>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</p>
</li>
<li><p><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</p>
</li>
<li><p><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</p>
</li>
<li><p><strong>ScalarHandler：</strong>查询单个值对象</p>
<p>​         </p>
</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer.class);</span><br><span class="line">	Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">	System.out.println(customer);	</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Customer.class);</span><br><span class="line">	List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">	list.forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;handle&quot;</span>);</span><br><span class="line"><span class="comment">//			return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));</span></span><br><span class="line">				</span><br><span class="line">			<span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">				<span class="keyword">int</span> id = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">				String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">				String email = rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">				Date birth = rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">		</span><br><span class="line">	Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">		</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"> * 使用ScalarHandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//测试一：</span></span><br><span class="line"><span class="comment">//	String sql = &quot;select count(*) from customers where id &lt; ?&quot;;</span></span><br><span class="line"><span class="comment">//	ScalarHandler handler = new ScalarHandler();</span></span><br><span class="line"><span class="comment">//	long count = (long) runner.query(conn, sql, handler, 20);</span></span><br><span class="line"><span class="comment">//	System.out.println(count);</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">//测试二：</span></span><br><span class="line">	String sql = <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line">	ScalarHandler handler = <span class="keyword">new</span> ScalarHandler();</span><br><span class="line">	Date birth = (Date) runner.query(conn, sql, handler);</span><br><span class="line">	System.out.println(birth);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeResource</span><span class="params">(Connection conn, Statement ps, ResultSet rs)</span></span>&#123;</span><br><span class="line">    DbUtils.closeQuietly(conn);</span><br><span class="line">    DbUtils.closeQuietly(ps);</span><br><span class="line">    DbUtils.closeQuietly(rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateWithTx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//1.获取连接的操作（</span></span><br><span class="line">		<span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line">		<span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid</span></span><br><span class="line">		<span class="comment">//2.对数据表进行一系列CRUD操作</span></span><br><span class="line">		<span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)</span></span><br><span class="line"><span class="comment">//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line">		<span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类</span></span><br><span class="line">			</span><br><span class="line">		<span class="comment">//提交数据</span></span><br><span class="line">		conn.commit();</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//回滚数据</span></span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//3.关闭连接等操作</span></span><br><span class="line">		<span class="comment">//① JDBCUtils.closeResource();</span></span><br><span class="line">		<span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作</span></span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
</search>
